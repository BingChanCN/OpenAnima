@using OpenAnima.Core.Services
@using OpenAnima.Core.Wiring
@using OpenAnima.Core.Ports
@using OpenAnima.Contracts.Ports
@inject IPortRegistry _portRegistry
@inject EditorStateService _editorState

<g transform="translate(@Node.Position.X, @Node.Position.Y)"
   class="node-card-root @(IsSelected ? "node-selected" : "")"
   @onmousedown:stopPropagation>
    <title>@GetStatusTooltip()</title>

    <!-- Background card -->
    <rect x="0" y="0"
          width="@_nodeWidth"
          height="@_nodeHeight"
          rx="8"
          fill="#1c1e2e"
          stroke="@GetBorderStroke()"
          stroke-width="@GetBorderWidth()"
          class="node-card-background @GetNodeStateClass()"
          @onclick="HandleCardClick"
          style="cursor: pointer;" />

    <!-- Title bar -->
    <rect x="0" y="0"
          width="@_nodeWidth"
          height="@_titleHeight"
          rx="8"
          fill="#161822"
          @onmousedown="HandleTitleBarMouseDown"
          @onmousedown:preventDefault
          style="cursor: move;" />

    <!-- Title text -->
    @((MarkupString)$"<text x=\"{_nodeWidth / 2}\" y=\"{_titleHeight / 2 + 4}\" fill=\"#e4e6f0\" font-size=\"13\" font-family=\"var(--font-family)\" text-anchor=\"middle\" font-weight=\"500\" style=\"pointer-events: none\">{Node.ModuleName}</text>")

    <!-- Status indicator -->
    <circle cx="@(_nodeWidth - 12)" cy="@(_titleHeight / 2)" r="4"
            class="node-status-dot @GetNodeStateClass()"
            fill="@_editorState.GetNodeBorderColor(Node.ModuleId)"
            style="cursor: default;" />

    @if (IsRunningState())
    {
        <circle cx="@(_nodeWidth - 12)" cy="@(_titleHeight / 2)" r="7"
                class="status-pulse" />
    }

    @if (IsErrorState())
    {
        @((MarkupString)$"<text x=\"{_nodeWidth - 27}\" y=\"{_titleHeight / 2 + 4}\" class=\"node-warning-icon\">âš </text>")
    }

    <!-- Input ports (left side) -->
    @foreach (var (port, index) in _inputPorts.Select((p, i) => (p, i)))
    {
        var portY = _titleHeight + index * _portSpacing + _portOffsetY;

        <circle cx="0" cy="@portY" r="6"
                fill="@PortColors.GetHex(port.Type)"
                @onmouseup="@(() => HandlePortMouseUp(port))"
                style="cursor: crosshair;" />

        @((MarkupString)$"<text x=\"14\" y=\"{portY + 4}\" fill=\"#8b8fa3\" font-size=\"11\" font-family=\"var(--font-family)\" style=\"pointer-events: none\">{port.Name}</text>")
    }

    <!-- Output ports (right side) -->
    @foreach (var (port, index) in _outputPorts.Select((p, i) => (p, i)))
    {
        var portY = _titleHeight + index * _portSpacing + _portOffsetY;

        <circle cx="@_nodeWidth" cy="@portY" r="6"
                fill="@PortColors.GetHex(port.Type)"
                @onmousedown="@(() => HandlePortMouseDown(port))"
                @onmousedown:preventDefault
                style="cursor: crosshair;" />

        @((MarkupString)$"<text x=\"{_nodeWidth - 14}\" y=\"{portY + 4}\" fill=\"#8b8fa3\" font-size=\"11\" font-family=\"var(--font-family)\" text-anchor=\"end\" style=\"pointer-events: none\">{port.Name}</text>")
    }
</g>

@code {
    [Parameter, EditorRequired]
    public ModuleNode Node { get; set; } = null!;

    [Parameter]
    public bool IsSelected { get; set; }

    private const double _nodeWidth = 200;
    private const double _titleHeight = 28;
    private const double _portSpacing = 24;
    private const double _portOffsetY = 12;
    private const double _minNodeHeight = 80;

    private List<PortMetadata> _inputPorts = new();
    private List<PortMetadata> _outputPorts = new();
    private double _nodeHeight;

    protected override void OnParametersSet()
    {
        var allPorts = _portRegistry.GetPorts(Node.ModuleName);
        _inputPorts = allPorts.Where(p => p.Direction == PortDirection.Input).ToList();
        _outputPorts = allPorts.Where(p => p.Direction == PortDirection.Output).ToList();

        var maxPorts = Math.Max(_inputPorts.Count, _outputPorts.Count);
        _nodeHeight = Math.Max(_minNodeHeight, _titleHeight + maxPorts * _portSpacing + _portOffsetY);
    }

    private void HandleTitleBarMouseDown(MouseEventArgs e)
    {
        var (canvasX, canvasY) = _editorState.ScreenToCanvas(e.ClientX, e.ClientY);
        _editorState.StartNodeDrag(Node.ModuleId, canvasX, canvasY);
    }

    private void HandleCardClick(MouseEventArgs e)
    {
        _editorState.SelectNode(Node.ModuleId, e.ShiftKey);
    }

    private void HandlePortMouseDown(PortMetadata port)
    {
        var portPos = _editorState.GetPortPosition(Node.ModuleId, port.Name, port.Direction);
        _editorState.StartConnectionDrag(Node.ModuleId, port.Name, port.Type, portPos.X, portPos.Y);
    }

    private void HandlePortMouseUp(PortMetadata port)
    {
        if (_editorState.IsDraggingConnection)
        {
            _editorState.EndConnectionDrag(Node.ModuleId, port.Name, port.Type);
        }
    }

    private bool IsRunningState()
    {
        return _editorState.GetModuleState(Node.ModuleId)?.State == "Running";
    }

    private bool IsErrorState()
    {
        return _editorState.GetModuleState(Node.ModuleId)?.State == "Error";
    }

    private string GetNodeStateClass()
    {
        var state = _editorState.GetModuleState(Node.ModuleId)?.State;
        return state switch
        {
            "Running" => "node-running",
            "Error" => "node-error",
            _ => "node-idle"
        };
    }

    private string GetBorderStroke()
    {
        return _editorState.GetNodeBorderColor(Node.ModuleId);
    }

    private double GetBorderWidth()
    {
        return IsSelected ? 2.2 : 1.2;
    }

    private string GetStatusTooltip()
    {
        var moduleState = _editorState.GetModuleState(Node.ModuleId);
        if (moduleState == null)
            return $"Status: Idle{Environment.NewLine}Node: {Node.ModuleName}";

        var statusText = moduleState.State switch
        {
            "Completed" => "Stopped",
            _ => moduleState.State
        };

        if (moduleState.State != "Error")
        {
            return $"Status: {statusText}{Environment.NewLine}Node: {Node.ModuleName}{Environment.NewLine}Updated: {moduleState.LastUpdated:HH:mm:ss} UTC";
        }

        var stackLine = string.IsNullOrWhiteSpace(moduleState.StackTrace)
            ? "None"
            : moduleState.StackTrace.Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries).FirstOrDefault() ?? "None";

        return $"Status: Error{Environment.NewLine}Node: {Node.ModuleName}{Environment.NewLine}Message: {moduleState.ErrorMessage}{Environment.NewLine}Stack: {stackLine}";
    }
}
