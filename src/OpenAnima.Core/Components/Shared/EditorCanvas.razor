@using OpenAnima.Core.Services
@using OpenAnima.Core.Wiring
@using OpenAnima.Core.Ports
@using OpenAnima.Contracts.Ports
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.JSInterop
@inject EditorStateService _state
@inject IPortRegistry _portRegistry
@inject IJSRuntime JS
@inject NavigationManager Navigation
@implements IAsyncDisposable

<div class="editor-canvas-wrapper"
     @ondragover:preventDefault
     @ondrop="HandleDrop">
    <svg @ref="_svgRef"
         class="editor-canvas @(_state.IsDraggingConnection || _state.IsDraggingNode || _isPanning ? "dragging" : "")"
         @onwheel="HandleWheel"
         @onwheel:preventDefault
         @onmousedown="HandleMouseDown"
         @onmousemove="HandleMouseMove"
         @onmouseup="HandleMouseUp"
         @oncontextmenu:preventDefault>

    <!-- Grid pattern -->
    <defs>
        <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
            <circle cx="1" cy="1" r="1" fill="rgba(139, 143, 163, 0.2)" />
        </pattern>
    </defs>

    <!-- Background with grid -->
    <rect width="100%" height="100%" fill="var(--bg-primary)" />
    <rect width="100%" height="100%" fill="url(#grid)" />

    <!-- Transformed content -->
    <g transform="matrix(@_state.Scale 0 0 @_state.Scale @_state.PanX @_state.PanY)">
        <!-- Render existing connections -->
        @foreach (var connection in _state.Configuration.Connections)
        {
            var start = _state.GetPortPosition(connection.SourceModuleId, connection.SourcePortName, PortDirection.Output);
            var end = _state.GetPortPosition(connection.TargetModuleId, connection.TargetPortName, PortDirection.Input);
            var sourceNode = _state.Configuration.Nodes.FirstOrDefault(n => n.ModuleId == connection.SourceModuleId);
            var color = sourceNode != null ? GetPortColor(sourceNode.ModuleName, connection.SourcePortName) : "#888888";
            var connectionId = $"{connection.SourceModuleId}:{connection.SourcePortName}->{connection.TargetModuleId}:{connection.TargetPortName}";
            var isSelected = _state.SelectedConnectionIds.Contains(connectionId);

            <ConnectionLine Start="@start" End="@end" Color="@color" IsPreview="false" IsSelected="@isSelected"
                          OnClick="@(() => HandleConnectionClick(connection))" />
        }

        <!-- Render preview connection during drag -->
        @if (_state.IsDraggingConnection && _state.DragSourceModuleId != null && _state.DragSourcePortName != null && _state.DragSourcePortType != null)
        {
            var start = _state.GetPortPosition(_state.DragSourceModuleId, _state.DragSourcePortName, PortDirection.Output);
            var end = (_state.DragConnectionMouseX, _state.DragConnectionMouseY);
            var color = PortColors.GetHex(_state.DragSourcePortType.Value);

            <ConnectionLine Start="@start" End="@end" Color="@color" IsPreview="true" IsSelected="false" />
        }

        @if (_state.GetConnectionRejection() is { } rejection)
        {
            var markerX = _state.DragConnectionMouseX;
            var markerY = _state.DragConnectionMouseY;
            var rejectionText = $"Incompatible: {rejection.SourcePortType} -> {rejection.TargetPortType}";

            <g class="connection-rejection-feedback" pointer-events="none">
                <circle cx="@markerX" cy="@markerY" r="16" class="rejection-ring" />
                <text x="@markerX" y="@(markerY + 5)" class="rejection-symbol" text-anchor="middle">×</text>
                <text x="@(markerX + 22)" y="@(markerY - 10)" class="rejection-label">@rejectionText</text>
            </g>
        }

        <!-- Render nodes -->
        @foreach (var node in _state.Configuration.Nodes)
        {
            <NodeCard Node="@node" IsSelected="@IsNodeSelected(node.ModuleId)" />
        }
    </g>
</svg>
</div>

@code {
    private ElementReference _svgRef;
    private bool _jsInitialized;
    private bool _isPanning;
    private double _panStartX;
    private double _panStartY;
    private DateTime _lastRenderTime = DateTime.MinValue;
    private const int RenderThrottleMs = 50;
    private HubConnection? _hubConnection;
    private CancellationTokenSource? _rejectionClearCts;

    protected override async Task OnInitializedAsync()
    {
        _state.OnStateChanged += HandleStateChanged;

        // Set up SignalR connection for module status updates
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/hubs/runtime"))
            .WithAutomaticReconnect()
            .Build();

        _hubConnection.On<string, string>("ReceiveModuleStateChanged", (moduleId, state) =>
        {
            _state.UpdateModuleState(moduleId, state);
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On<string, string, string?>("ReceiveModuleError", (moduleId, errorMsg, stackTrace) =>
        {
            _state.UpdateModuleError(moduleId, errorMsg, stackTrace);
            InvokeAsync(StateHasChanged);
        });

        try
        {
            await _hubConnection.StartAsync();
        }
        catch
        {
            // SignalR connection failure is non-fatal for editor
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_jsInitialized)
        {
            _jsInitialized = true;
            await JS.InvokeVoidAsync("editorCanvas.init", _svgRef);
            await UpdateCanvasOffset();
        }
    }

    private async Task UpdateCanvasOffset()
    {
        var bounds = await JS.InvokeAsync<SvgBounds>("editorCanvas.getBounds", _svgRef);
        _state.UpdateCanvasOffset(bounds.Left, bounds.Top);
    }

    private record SvgBounds(double Left, double Top);

    private void HandleStateChanged()
    {
        ScheduleRejectionClear();

        // Skip during drag — HandleMouseMove controls throttled rendering directly
        if (_state.IsDraggingNode || _state.IsDraggingConnection || _isPanning)
            return;

        InvokeAsync(StateHasChanged);
    }

    private void ScheduleRejectionClear()
    {
        var rejection = _state.GetConnectionRejection();
        if (rejection == null)
        {
            _rejectionClearCts?.Cancel();
            _rejectionClearCts?.Dispose();
            _rejectionClearCts = null;
            return;
        }

        var delay = rejection.ExpiresAt - DateTime.UtcNow;
        if (delay <= TimeSpan.Zero)
        {
            _state.ClearExpiredConnectionRejection();
            return;
        }

        _rejectionClearCts?.Cancel();
        _rejectionClearCts?.Dispose();
        _rejectionClearCts = new CancellationTokenSource();
        var token = _rejectionClearCts.Token;

        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(delay, token);
                if (token.IsCancellationRequested)
                    return;

                await InvokeAsync(() =>
                {
                    _state.ClearExpiredConnectionRejection();
                    StateHasChanged();
                });
            }
            catch (TaskCanceledException)
            {
                // Ignore cancelled delay from subsequent rejection events.
            }
        }, token);
    }

    private bool IsNodeSelected(string moduleId)
    {
        return _state.SelectedNodeIds.Contains(moduleId);
    }

    private string GetPortColor(string moduleName, string portName)
    {
        var ports = _portRegistry.GetPorts(moduleName);
        var port = ports.FirstOrDefault(p => p.Name == portName);
        return port != null ? PortColors.GetHex(port.Type) : "#888888";
    }

    private void HandleConnectionClick(PortConnection connection)
    {
        _state.SelectConnection(connection.SourceModuleId, connection.SourcePortName,
                               connection.TargetModuleId, connection.TargetPortName, false);
    }

    private void HandleWheel(WheelEventArgs e)
    {
        // Zoom centered on cursor
        var oldScale = _state.Scale;
        var zoomFactor = e.DeltaY < 0 ? 1.1 : 0.9;
        var newScale = Math.Clamp(oldScale * zoomFactor, 0.1, 3.0);

        // Convert viewport coordinates to SVG-local coordinates
        var mouseX = e.ClientX - _state.CanvasOffsetX;
        var mouseY = e.ClientY - _state.CanvasOffsetY;
        var newPanX = mouseX - newScale * (mouseX - _state.PanX) / oldScale;
        var newPanY = mouseY - newScale * (mouseY - _state.PanY) / oldScale;

        _state.UpdateScale(newScale);
        _state.UpdatePan(newPanX, newPanY);
    }

    private async Task HandleMouseDown(MouseEventArgs e)
    {
        // Refresh canvas offset in case layout changed
        await UpdateCanvasOffset();

        // Clear selection on background click
        _state.ClearSelection();

        // Start panning on background click (use SVG-local coordinates)
        _isPanning = true;
        _panStartX = e.ClientX - _state.CanvasOffsetX - _state.PanX;
        _panStartY = e.ClientY - _state.CanvasOffsetY - _state.PanY;
    }

    private void HandleMouseMove(MouseEventArgs e)
    {
        // Convert to canvas coordinates
        var (canvasX, canvasY) = _state.ScreenToCanvas(e.ClientX, e.ClientY);

        // Handle node dragging
        if (_state.IsDraggingNode)
        {
            _state.UpdateNodeDrag(canvasX, canvasY);

            var now = DateTime.UtcNow;
            if ((now - _lastRenderTime).TotalMilliseconds >= RenderThrottleMs)
            {
                _lastRenderTime = now;
                StateHasChanged();
            }
            return;
        }

        // Handle connection dragging
        if (_state.IsDraggingConnection)
        {
            _state.UpdateConnectionDrag(canvasX, canvasY);

            var now = DateTime.UtcNow;
            if ((now - _lastRenderTime).TotalMilliseconds >= RenderThrottleMs)
            {
                _lastRenderTime = now;
                StateHasChanged();
            }
            return;
        }

        // Handle canvas panning
        if (_isPanning)
        {
            var newPanX = e.ClientX - _state.CanvasOffsetX - _panStartX;
            var newPanY = e.ClientY - _state.CanvasOffsetY - _panStartY;

            // Update state immediately but throttle rendering
            _state.UpdatePan(newPanX, newPanY);

            var now = DateTime.UtcNow;
            if ((now - _lastRenderTime).TotalMilliseconds >= RenderThrottleMs)
            {
                _lastRenderTime = now;
                StateHasChanged();
            }
        }
    }

    private void HandleMouseUp(MouseEventArgs e)
    {
        // End node dragging
        if (_state.IsDraggingNode)
        {
            _state.EndNodeDrag();
            StateHasChanged();
            return;
        }

        // End connection dragging (cancel if not on a port)
        if (_state.IsDraggingConnection)
        {
            _state.EndConnectionDrag(null, null, null);
            StateHasChanged();
            return;
        }

        // End canvas panning
        _isPanning = false;
        StateHasChanged(); // Final render after pan ends
    }

    private async Task HandleDrop(DragEventArgs e)
    {
        // Capture before await — DraggedModuleName can be cleared during async gap
        var moduleName = _state.DraggedModuleName;
        if (string.IsNullOrEmpty(moduleName))
            return;

        // Clear drag state immediately to prevent double-drop
        _state.DraggedModuleName = null;

        // Refresh canvas offset for accurate coordinate conversion
        await UpdateCanvasOffset();

        // Convert screen coordinates to canvas coordinates
        var (canvasX, canvasY) = _state.ScreenToCanvas(e.ClientX, e.ClientY);

        // Add node at drop position
        _state.AddNode(moduleName, canvasX, canvasY);
    }

    public async ValueTask DisposeAsync()
    {
        _state.OnStateChanged -= HandleStateChanged;
        _rejectionClearCts?.Cancel();
        _rejectionClearCts?.Dispose();
        if (_hubConnection != null)
        {
            try { await _hubConnection.DisposeAsync(); }
            catch { }
        }
        if (_jsInitialized)
        {
            try { await JS.InvokeVoidAsync("editorCanvas.dispose", _svgRef); }
            catch (JSDisconnectedException) { }
        }
    }
}
