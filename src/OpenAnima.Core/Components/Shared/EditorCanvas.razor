@using OpenAnima.Core.Services
@using OpenAnima.Core.Wiring
@using OpenAnima.Core.Ports
@using OpenAnima.Contracts.Ports
@using Microsoft.AspNetCore.Components
@using Microsoft.JSInterop
@inject EditorStateService _state
@inject IPortRegistry _portRegistry
@inject IJSRuntime JS
@implements IAsyncDisposable

<svg @ref="_svgRef"
     class="editor-canvas"
     @onwheel="HandleWheel"
     @onwheel:preventDefault
     @onmousedown="HandleMouseDown"
     @onmousemove="HandleMouseMove"
     @onmouseup="HandleMouseUp"
     @oncontextmenu:preventDefault
     @ondragover:preventDefault
     @ondrop="HandleDrop">

    <!-- Grid pattern -->
    <defs>
        <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
            <circle cx="1" cy="1" r="1" fill="rgba(139, 143, 163, 0.2)" />
        </pattern>
    </defs>

    <!-- Background with grid -->
    <rect width="100%" height="100%" fill="var(--bg-primary)" />
    <rect width="100%" height="100%" fill="url(#grid)" />

    <!-- Transformed content -->
    <g transform="matrix(@_state.Scale 0 0 @_state.Scale @_state.PanX @_state.PanY)">
        <!-- Render existing connections -->
        @foreach (var connection in _state.Configuration.Connections)
        {
            var start = _state.GetPortPosition(connection.SourceModuleId, connection.SourcePortName, PortDirection.Output);
            var end = _state.GetPortPosition(connection.TargetModuleId, connection.TargetPortName, PortDirection.Input);
            var sourceNode = _state.Configuration.Nodes.FirstOrDefault(n => n.ModuleId == connection.SourceModuleId);
            var color = sourceNode != null ? GetPortColor(sourceNode.ModuleName, connection.SourcePortName) : "#888888";
            var connectionId = $"{connection.SourceModuleId}:{connection.SourcePortName}->{connection.TargetModuleId}:{connection.TargetPortName}";
            var isSelected = _state.SelectedConnectionIds.Contains(connectionId);

            <ConnectionLine Start="@start" End="@end" Color="@color" IsPreview="false" IsSelected="@isSelected"
                          OnClick="@(() => HandleConnectionClick(connection))" />
        }

        <!-- Render preview connection during drag -->
        @if (_state.IsDraggingConnection && _state.DragSourceModuleId != null && _state.DragSourcePortName != null && _state.DragSourcePortType != null)
        {
            var start = _state.GetPortPosition(_state.DragSourceModuleId, _state.DragSourcePortName, PortDirection.Output);
            var end = (_state.DragConnectionMouseX, _state.DragConnectionMouseY);
            var color = PortColors.GetHex(_state.DragSourcePortType.Value);

            <ConnectionLine Start="@start" End="@end" Color="@color" IsPreview="true" IsSelected="false" />
        }

        <!-- Render nodes -->
        @foreach (var node in _state.Configuration.Nodes)
        {
            <NodeCard Node="@node" IsSelected="@IsNodeSelected(node.ModuleId)" />
        }
    </g>
</svg>

@code {
    private ElementReference _svgRef;
    private bool _jsInitialized;
    private bool _isPanning;
    private double _panStartX;
    private double _panStartY;
    private DateTime _lastRenderTime = DateTime.MinValue;
    private const int RenderThrottleMs = 50;

    protected override void OnInitialized()
    {
        _state.OnStateChanged += HandleStateChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_jsInitialized)
        {
            _jsInitialized = true;
            await JS.InvokeVoidAsync("editorCanvas.init", _svgRef);
        }
    }

    private void HandleStateChanged()
    {
        StateHasChanged();
    }

    private bool IsNodeSelected(string moduleId)
    {
        return _state.SelectedNodeIds.Contains(moduleId);
    }

    private string GetPortColor(string moduleName, string portName)
    {
        var ports = _portRegistry.GetPorts(moduleName);
        var port = ports.FirstOrDefault(p => p.Name == portName);
        return port != null ? PortColors.GetHex(port.Type) : "#888888";
    }

    private void HandleConnectionClick(PortConnection connection)
    {
        _state.SelectConnection(connection.SourceModuleId, connection.SourcePortName,
                               connection.TargetModuleId, connection.TargetPortName, false);
    }

    private void HandleWheel(WheelEventArgs e)
    {
        // Zoom centered on cursor
        var oldScale = _state.Scale;
        var zoomFactor = e.DeltaY < 0 ? 1.1 : 0.9;
        var newScale = Math.Clamp(oldScale * zoomFactor, 0.1, 3.0);

        // Adjust pan to keep mouse position fixed
        var mouseX = e.ClientX;
        var mouseY = e.ClientY;
        var newPanX = mouseX - newScale * (mouseX - _state.PanX) / oldScale;
        var newPanY = mouseY - newScale * (mouseY - _state.PanY) / oldScale;

        _state.UpdateScale(newScale);
        _state.UpdatePan(newPanX, newPanY);
    }

    private void HandleMouseDown(MouseEventArgs e)
    {
        // Clear selection on background click
        _state.ClearSelection();

        // Start panning on background click
        _isPanning = true;
        _panStartX = e.ClientX - _state.PanX;
        _panStartY = e.ClientY - _state.PanY;
    }

    private void HandleMouseMove(MouseEventArgs e)
    {
        // Convert to canvas coordinates
        var (canvasX, canvasY) = _state.ScreenToCanvas(e.ClientX, e.ClientY);

        // Handle node dragging
        if (_state.IsDraggingNode)
        {
            _state.UpdateNodeDrag(canvasX, canvasY);

            var now = DateTime.UtcNow;
            if ((now - _lastRenderTime).TotalMilliseconds >= RenderThrottleMs)
            {
                _lastRenderTime = now;
                StateHasChanged();
            }
            return;
        }

        // Handle connection dragging
        if (_state.IsDraggingConnection)
        {
            _state.UpdateConnectionDrag(canvasX, canvasY);

            var now = DateTime.UtcNow;
            if ((now - _lastRenderTime).TotalMilliseconds >= RenderThrottleMs)
            {
                _lastRenderTime = now;
                StateHasChanged();
            }
            return;
        }

        // Handle canvas panning
        if (_isPanning)
        {
            var newPanX = e.ClientX - _panStartX;
            var newPanY = e.ClientY - _panStartY;

            // Update state immediately but throttle rendering
            _state.UpdatePan(newPanX, newPanY);

            var now = DateTime.UtcNow;
            if ((now - _lastRenderTime).TotalMilliseconds >= RenderThrottleMs)
            {
                _lastRenderTime = now;
                StateHasChanged();
            }
        }
    }

    private void HandleMouseUp(MouseEventArgs e)
    {
        // End node dragging
        if (_state.IsDraggingNode)
        {
            _state.EndNodeDrag();
            StateHasChanged();
            return;
        }

        // End connection dragging (cancel if not on a port)
        if (_state.IsDraggingConnection)
        {
            _state.EndConnectionDrag(null, null, null);
            StateHasChanged();
            return;
        }

        // End canvas panning
        _isPanning = false;
        StateHasChanged(); // Final render after pan ends
    }

    private void HandleDrop(DragEventArgs e)
    {
        if (string.IsNullOrEmpty(_state.DraggedModuleName))
            return;

        // Convert screen coordinates to canvas coordinates
        var (canvasX, canvasY) = _state.ScreenToCanvas(e.ClientX, e.ClientY);

        // Add node at drop position
        _state.AddNode(_state.DraggedModuleName, canvasX, canvasY);

        // Clear drag state
        _state.DraggedModuleName = null;
    }

    public async ValueTask DisposeAsync()
    {
        _state.OnStateChanged -= HandleStateChanged;
        if (_jsInitialized)
        {
            try { await JS.InvokeVoidAsync("editorCanvas.dispose", _svgRef); }
            catch (JSDisconnectedException) { }
        }
    }
}
