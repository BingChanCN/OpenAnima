@using OpenAnima.Core.Services
@using Microsoft.AspNetCore.Components
@inject EditorStateService _state

<svg class="editor-canvas"
     @onwheel="HandleWheel"
     @onwheel:preventDefault
     @onmousedown="HandleMouseDown"
     @onmousemove="HandleMouseMove"
     @onmouseup="HandleMouseUp"
     @ondragover:preventDefault
     @ondrop="HandleDrop">

    <!-- Grid pattern -->
    <defs>
        <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
            <circle cx="1" cy="1" r="1" fill="rgba(139, 143, 163, 0.2)" />
        </pattern>
    </defs>

    <!-- Background with grid -->
    <rect width="100%" height="100%" fill="var(--bg-primary)" />
    <rect width="100%" height="100%" fill="url(#grid)" />

    <!-- Transformed content -->
    <g transform="matrix(@_state.Scale 0 0 @_state.Scale @_state.PanX @_state.PanY)">
        @foreach (var node in _state.Configuration.Nodes)
        {
            <NodeCard Node="@node" IsSelected="@IsNodeSelected(node.ModuleId)" />
        }
    </g>
</svg>

@code {
    private bool _isPanning;
    private double _panStartX;
    private double _panStartY;
    private DateTime _lastRenderTime = DateTime.MinValue;
    private const int RenderThrottleMs = 50;

    protected override void OnInitialized()
    {
        _state.OnStateChanged += HandleStateChanged;
    }

    private void HandleStateChanged()
    {
        StateHasChanged();
    }

    private bool IsNodeSelected(string moduleId)
    {
        return _state.SelectedNodeIds.Contains(moduleId);
    }

    private void HandleWheel(WheelEventArgs e)
    {
        // Zoom centered on cursor
        var oldScale = _state.Scale;
        var zoomFactor = e.DeltaY < 0 ? 1.1 : 0.9;
        var newScale = Math.Clamp(oldScale * zoomFactor, 0.1, 3.0);

        // Adjust pan to keep mouse position fixed
        var mouseX = e.ClientX;
        var mouseY = e.ClientY;
        var newPanX = mouseX - newScale * (mouseX - _state.PanX) / oldScale;
        var newPanY = mouseY - newScale * (mouseY - _state.PanY) / oldScale;

        _state.UpdateScale(newScale);
        _state.UpdatePan(newPanX, newPanY);
    }

    private void HandleMouseDown(MouseEventArgs e)
    {
        // Start panning on background click
        _isPanning = true;
        _panStartX = e.ClientX - _state.PanX;
        _panStartY = e.ClientY - _state.PanY;
    }

    private void HandleMouseMove(MouseEventArgs e)
    {
        // Convert to canvas coordinates
        var (canvasX, canvasY) = _state.ScreenToCanvas(e.ClientX, e.ClientY);

        // Handle node dragging
        if (_state.IsDraggingNode)
        {
            _state.UpdateNodeDrag(canvasX, canvasY);

            var now = DateTime.UtcNow;
            if ((now - _lastRenderTime).TotalMilliseconds >= RenderThrottleMs)
            {
                _lastRenderTime = now;
                StateHasChanged();
            }
            return;
        }

        // Handle connection dragging
        if (_state.IsDraggingConnection)
        {
            _state.UpdateConnectionDrag(canvasX, canvasY);

            var now = DateTime.UtcNow;
            if ((now - _lastRenderTime).TotalMilliseconds >= RenderThrottleMs)
            {
                _lastRenderTime = now;
                StateHasChanged();
            }
            return;
        }

        // Handle canvas panning
        if (_isPanning)
        {
            var newPanX = e.ClientX - _panStartX;
            var newPanY = e.ClientY - _panStartY;

            // Update state immediately but throttle rendering
            _state.UpdatePan(newPanX, newPanY);

            var now = DateTime.UtcNow;
            if ((now - _lastRenderTime).TotalMilliseconds >= RenderThrottleMs)
            {
                _lastRenderTime = now;
                StateHasChanged();
            }
        }
    }

    private void HandleMouseUp(MouseEventArgs e)
    {
        // End node dragging
        if (_state.IsDraggingNode)
        {
            _state.EndNodeDrag();
            StateHasChanged();
            return;
        }

        // End connection dragging (cancel if not on a port)
        if (_state.IsDraggingConnection)
        {
            _state.EndConnectionDrag(null, null, null);
            StateHasChanged();
            return;
        }

        // End canvas panning
        _isPanning = false;
        StateHasChanged(); // Final render after pan ends
    }

    private void HandleDrop(DragEventArgs e)
    {
        if (string.IsNullOrEmpty(_state.DraggedModuleName))
            return;

        // Convert screen coordinates to canvas coordinates
        var (canvasX, canvasY) = _state.ScreenToCanvas(e.ClientX, e.ClientY);

        // Add node at drop position
        _state.AddNode(_state.DraggedModuleName, canvasX, canvasY);

        // Clear drag state
        _state.DraggedModuleName = null;
    }

    public void Dispose()
    {
        _state.OnStateChanged -= HandleStateChanged;
    }
}
