---
phase: 05-signalr-real-time-updates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/OpenAnima.Core/Hubs/IRuntimeClient.cs
  - src/OpenAnima.Core/Hubs/RuntimeHub.cs
  - src/OpenAnima.Core/Runtime/HeartbeatLoop.cs
  - src/OpenAnima.Core/Services/IHeartbeatService.cs
  - src/OpenAnima.Core/Services/HeartbeatService.cs
  - src/OpenAnima.Core/Services/ModuleService.cs
  - src/OpenAnima.Core/Services/IModuleService.cs
  - src/OpenAnima.Core/OpenAnima.Core.csproj
  - src/OpenAnima.Core/Program.cs
autonomous: true
requirements:
  - INFRA-02

must_haves:
  truths:
    - "SignalR Hub is registered and accessible at /hubs/runtime endpoint"
    - "HeartbeatLoop pushes tick count and latency to all connected clients on every tick"
    - "HeartbeatLoop exposes per-tick latency via LastTickLatencyMs property"
    - "ModuleService pushes module count change when a module is loaded"
    - "HeartbeatLoop pushes running state change on start and stop"
  artifacts:
    - path: "src/OpenAnima.Core/Hubs/IRuntimeClient.cs"
      provides: "Strongly-typed client interface for server-to-client push"
      contains: "ReceiveHeartbeatTick"
    - path: "src/OpenAnima.Core/Hubs/RuntimeHub.cs"
      provides: "SignalR Hub for runtime data push"
      contains: "Hub<IRuntimeClient>"
    - path: "src/OpenAnima.Core/Runtime/HeartbeatLoop.cs"
      provides: "Latency tracking and Hub push on each tick"
      contains: "IHubContext"
    - path: "src/OpenAnima.Core/Program.cs"
      provides: "SignalR service registration and Hub endpoint mapping"
      contains: "MapHub<RuntimeHub>"
  key_links:
    - from: "HeartbeatLoop.cs"
      to: "RuntimeHub"
      via: "IHubContext<RuntimeHub, IRuntimeClient>"
      pattern: "IHubContext<RuntimeHub"
    - from: "Program.cs"
      to: "RuntimeHub"
      via: "MapHub endpoint registration"
      pattern: "MapHub<RuntimeHub>"
    - from: "ModuleService.cs"
      to: "RuntimeHub"
      via: "IHubContext<RuntimeHub, IRuntimeClient>"
      pattern: "IHubContext<RuntimeHub"
---

<objective>
Create the SignalR Hub infrastructure, add per-tick latency tracking to HeartbeatLoop, and wire up server-to-client push for heartbeat ticks, state changes, and module list changes.

Purpose: Establishes the real-time data pipeline from runtime to browser. This is the backend foundation that Plan 05-02's monitoring UI will consume. Without this, the UI has no live data source.

Output: RuntimeHub mapped at /hubs/runtime, HeartbeatLoop pushing tick+latency on every tick, ModuleService pushing module count changes, IHeartbeatService exposing LastTickLatencyMs.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-signalr-real-time-updates/05-CONTEXT.md
@.planning/phases/05-signalr-real-time-updates/05-RESEARCH.md
@src/OpenAnima.Core/Runtime/HeartbeatLoop.cs
@src/OpenAnima.Core/Services/IHeartbeatService.cs
@src/OpenAnima.Core/Services/HeartbeatService.cs
@src/OpenAnima.Core/Services/ModuleService.cs
@src/OpenAnima.Core/Services/IModuleService.cs
@src/OpenAnima.Core/Program.cs
@src/OpenAnima.Core/OpenAnima.Core.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SignalR Hub infrastructure and register in Program.cs</name>
  <files>
    src/OpenAnima.Core/Hubs/IRuntimeClient.cs
    src/OpenAnima.Core/Hubs/RuntimeHub.cs
    src/OpenAnima.Core/OpenAnima.Core.csproj
    src/OpenAnima.Core/Program.cs
  </files>
  <action>
**Add NuGet package:**
```bash
dotnet add src/OpenAnima.Core/OpenAnima.Core.csproj package Microsoft.AspNetCore.SignalR.Client
```

**Create `src/OpenAnima.Core/Hubs/IRuntimeClient.cs`:**

Strongly-typed client interface defining all server-to-client push methods:

```csharp
namespace OpenAnima.Core.Hubs;

/// <summary>
/// Defines methods the server can invoke on connected clients.
/// Used with Hub<IRuntimeClient> for compile-time safety.
/// </summary>
public interface IRuntimeClient
{
    /// <summary>
    /// Pushes heartbeat tick data to clients.
    /// </summary>
    /// <param name="tickCount">Current tick count</param>
    /// <param name="latencyMs">Duration of this tick in milliseconds</param>
    Task ReceiveHeartbeatTick(long tickCount, double latencyMs);

    /// <summary>
    /// Pushes heartbeat running state change to clients.
    /// </summary>
    /// <param name="isRunning">Whether heartbeat is now running</param>
    Task ReceiveHeartbeatStateChanged(bool isRunning);

    /// <summary>
    /// Pushes module list change notification to clients.
    /// </summary>
    /// <param name="moduleCount">Current number of loaded modules</param>
    Task ReceiveModuleCountChanged(int moduleCount);
}
```

**Create `src/OpenAnima.Core/Hubs/RuntimeHub.cs`:**

```csharp
using Microsoft.AspNetCore.SignalR;

namespace OpenAnima.Core.Hubs;

/// <summary>
/// SignalR Hub for pushing runtime state to connected dashboard clients.
/// Server-push only — no client-to-server methods needed for Phase 5.
/// </summary>
public class RuntimeHub : Hub<IRuntimeClient>
{
}
```

**Update `src/OpenAnima.Core/Program.cs`:**

1. Add `using OpenAnima.Core.Hubs;` at the top.
2. After `builder.Services.AddRazorComponents().AddInteractiveServerComponents();` add:
   ```csharp
   builder.Services.AddSignalR();
   ```
3. After `app.MapRazorComponents<OpenAnima.Core.Components.App>().AddInteractiveServerRenderMode();` add:
   ```csharp
   app.MapHub<RuntimeHub>("/hubs/runtime");
   ```
  </action>
  <verify>
Run `dotnet build src/OpenAnima.Core/` — must compile without errors. Verify IRuntimeClient.cs has three methods (ReceiveHeartbeatTick, ReceiveHeartbeatStateChanged, ReceiveModuleCountChanged). Verify RuntimeHub inherits Hub&lt;IRuntimeClient&gt;. Verify Program.cs has AddSignalR() and MapHub.
  </verify>
  <done>
SignalR Hub infrastructure is in place. RuntimeHub is mapped at /hubs/runtime. IRuntimeClient defines the strongly-typed push contract. SignalR services are registered in DI.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add latency tracking to HeartbeatLoop and wire Hub push</name>
  <files>
    src/OpenAnima.Core/Runtime/HeartbeatLoop.cs
    src/OpenAnima.Core/Services/IHeartbeatService.cs
    src/OpenAnima.Core/Services/HeartbeatService.cs
    src/OpenAnima.Core/Services/ModuleService.cs
    src/OpenAnima.Core/Services/IModuleService.cs
    src/OpenAnima.Core/Program.cs
  </files>
  <action>
**Update `src/OpenAnima.Core/Runtime/HeartbeatLoop.cs`:**

1. Add `using System.Diagnostics;` and `using OpenAnima.Core.Hubs;` and `using Microsoft.AspNetCore.SignalR;` at the top.

2. Add a new field and property:
   ```csharp
   private readonly IHubContext<RuntimeHub, IRuntimeClient>? _hubContext;
   private double _lastTickLatencyMs;
   public double LastTickLatencyMs => _lastTickLatencyMs;
   ```

3. Update the constructor to accept an optional `IHubContext<RuntimeHub, IRuntimeClient>? hubContext = null` parameter. Store it in `_hubContext`. Keep the parameter optional (nullable) so existing tests/usage without DI still work.

4. In `ExecuteTickAsync`, replace the existing `DateTime.UtcNow` timing with `Stopwatch`:
   - At the start: `var sw = Stopwatch.StartNew();`
   - After all tick work completes (after the `Task.WhenAll` and before the duration check): `sw.Stop(); var latencyMs = sw.Elapsed.TotalMilliseconds; _lastTickLatencyMs = latencyMs;`
   - Replace the existing `var duration = (DateTime.UtcNow - startTime).TotalMilliseconds;` with `var duration = latencyMs;`
   - Remove the `var startTime = DateTime.UtcNow;` line.

5. After the latency measurement, push to Hub:
   ```csharp
   if (_hubContext != null)
   {
       _ = _hubContext.Clients.All.ReceiveHeartbeatTick(_tickCount, latencyMs);
   }
   ```
   Use fire-and-forget (`_ =`) to avoid blocking the tick loop.

6. In `StartAsync`, after setting up the loop task, push state change:
   ```csharp
   if (_hubContext != null)
   {
       _ = _hubContext.Clients.All.ReceiveHeartbeatStateChanged(true);
   }
   ```

7. In `StopAsync`, after cancellation and cleanup, push state change:
   ```csharp
   if (_hubContext != null)
   {
       _ = _hubContext.Clients.All.ReceiveHeartbeatStateChanged(false);
   }
   ```

**Update `src/OpenAnima.Core/Services/IHeartbeatService.cs`:**

Add property:
```csharp
/// <summary>
/// Duration of the last tick in milliseconds.
/// </summary>
double LastTickLatencyMs { get; }
```

**Update `src/OpenAnima.Core/Services/HeartbeatService.cs`:**

Add property delegation:
```csharp
public double LastTickLatencyMs => _heartbeat.LastTickLatencyMs;
```

**Update `src/OpenAnima.Core/Program.cs`:**

Update the HeartbeatLoop registration to inject IHubContext. Change the factory:
```csharp
builder.Services.AddSingleton<HeartbeatLoop>(sp =>
    new HeartbeatLoop(
        sp.GetRequiredService<IEventBus>(),
        sp.GetRequiredService<PluginRegistry>(),
        TimeSpan.FromMilliseconds(100),
        sp.GetRequiredService<ILogger<HeartbeatLoop>>(),
        sp.GetRequiredService<IHubContext<RuntimeHub, IRuntimeClient>>()));
```

**Update `src/OpenAnima.Core/Services/IModuleService.cs`:**

No interface change needed — the push happens inside ModuleService implementation.

**Update `src/OpenAnima.Core/Services/ModuleService.cs`:**

1. Add `using OpenAnima.Core.Hubs;` and `using Microsoft.AspNetCore.SignalR;`.
2. Add `IHubContext<RuntimeHub, IRuntimeClient>` to the constructor and store as `_hubContext`.
3. In `LoadModule`, after successful registration (after `_logger.LogInformation("Loaded module...")`), add:
   ```csharp
   _ = _hubContext.Clients.All.ReceiveModuleCountChanged(_registry.Count);
   ```
4. In `ScanAndLoadAll`, after the foreach loop completes (before `return results;`), add:
   ```csharp
   _ = _hubContext.Clients.All.ReceiveModuleCountChanged(_registry.Count);
   ```
  </action>
  <verify>
Run `dotnet build src/OpenAnima.Core/` — must compile without errors. Verify HeartbeatLoop has IHubContext field and pushes on tick, start, and stop. Verify IHeartbeatService has LastTickLatencyMs. Verify ModuleService pushes module count changes. Verify Program.cs passes IHubContext to HeartbeatLoop factory.
  </verify>
  <done>
HeartbeatLoop tracks per-tick latency with Stopwatch and pushes tick count + latency to all connected clients via SignalR on every tick. State changes (start/stop) are pushed. ModuleService pushes module count changes on load. IHeartbeatService exposes LastTickLatencyMs for direct access.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/OpenAnima.Core/` compiles without errors
2. IRuntimeClient.cs defines ReceiveHeartbeatTick, ReceiveHeartbeatStateChanged, ReceiveModuleCountChanged
3. RuntimeHub inherits Hub<IRuntimeClient>
4. Program.cs has AddSignalR() and MapHub<RuntimeHub>("/hubs/runtime")
5. HeartbeatLoop uses Stopwatch for latency and pushes via IHubContext on every tick
6. HeartbeatLoop pushes state change on StartAsync and StopAsync
7. ModuleService pushes module count change on LoadModule and ScanAndLoadAll
8. IHeartbeatService exposes LastTickLatencyMs property
</verification>

<success_criteria>
- SignalR Hub registered at /hubs/runtime
- HeartbeatLoop pushes tick count + latency on every tick via IHubContext
- HeartbeatLoop pushes running state on start/stop
- ModuleService pushes module count on load
- Per-tick latency tracked with Stopwatch and exposed via IHeartbeatService
- Clean build with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-signalr-real-time-updates/05-01-SUMMARY.md`
</output>
