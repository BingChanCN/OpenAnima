---
phase: 06-control-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/OpenAnima.Core/Plugins/PluginLoadContext.cs
  - src/OpenAnima.Core/Plugins/PluginRegistry.cs
  - src/OpenAnima.Core/Services/IModuleService.cs
  - src/OpenAnima.Core/Services/ModuleService.cs
  - src/OpenAnima.Core/Hubs/RuntimeHub.cs
autonomous: true
requirements: [MOD-08, MOD-09, MOD-10, BEAT-02]

must_haves:
  truths:
    - "RuntimeHub exposes LoadModule, UnloadModule, GetAvailableModules, StartHeartbeat, StopHeartbeat methods callable by clients"
    - "ModuleService can unload a module by name, removing it from registry and unloading its AssemblyLoadContext"
    - "ModuleService can list available (not-yet-loaded) module directories"
    - "PluginLoadContext uses isCollectible: true to enable unloading"
    - "PluginRegistry has an Unregister method that removes entry and unloads context"
  artifacts:
    - path: "src/OpenAnima.Core/Hubs/RuntimeHub.cs"
      provides: "Client-to-server Hub methods for all control operations"
      contains: "LoadModule"
    - path: "src/OpenAnima.Core/Plugins/PluginLoadContext.cs"
      provides: "Collectible assembly load context"
      contains: "isCollectible: true"
    - path: "src/OpenAnima.Core/Plugins/PluginRegistry.cs"
      provides: "Unregister method for module removal"
      contains: "Unregister"
    - path: "src/OpenAnima.Core/Services/IModuleService.cs"
      provides: "UnloadModule and GetAvailableModules interface methods"
      exports: ["UnloadModule", "GetAvailableModules"]
    - path: "src/OpenAnima.Core/Services/ModuleService.cs"
      provides: "Implementation of unload and available modules discovery"
      contains: "UnloadModule"
  key_links:
    - from: "src/OpenAnima.Core/Hubs/RuntimeHub.cs"
      to: "src/OpenAnima.Core/Services/IModuleService.cs"
      via: "DI constructor injection"
      pattern: "IModuleService"
    - from: "src/OpenAnima.Core/Hubs/RuntimeHub.cs"
      to: "src/OpenAnima.Core/Services/IHeartbeatService.cs"
      via: "DI constructor injection"
      pattern: "IHeartbeatService"
    - from: "src/OpenAnima.Core/Services/ModuleService.cs"
      to: "src/OpenAnima.Core/Plugins/PluginRegistry.cs"
      via: "Unregister call"
      pattern: "_registry.Unregister"
---

<objective>
Add backend control operations: Hub methods for client-to-server RPC, module unload capability, available module discovery, and heartbeat start/stop.

Purpose: Phase 5 established server-to-client push. Phase 6 needs the reverse — client-to-server invocation via SignalR Hub methods. This plan builds all backend infrastructure so the UI plan (06-02) can wire buttons to real operations.

Output: RuntimeHub with 5 callable methods, ModuleService with unload + discovery, PluginRegistry.Unregister, collectible PluginLoadContext.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-signalr-real-time-updates/05-01-SUMMARY.md
@src/OpenAnima.Core/Hubs/RuntimeHub.cs
@src/OpenAnima.Core/Hubs/IRuntimeClient.cs
@src/OpenAnima.Core/Services/IModuleService.cs
@src/OpenAnima.Core/Services/ModuleService.cs
@src/OpenAnima.Core/Services/IHeartbeatService.cs
@src/OpenAnima.Core/Plugins/PluginRegistry.cs
@src/OpenAnima.Core/Plugins/PluginLoadContext.cs
@src/OpenAnima.Core/Hosting/OpenAnimaHostedService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable module unloading infrastructure</name>
  <files>
    src/OpenAnima.Core/Plugins/PluginLoadContext.cs
    src/OpenAnima.Core/Plugins/PluginRegistry.cs
    src/OpenAnima.Core/Services/IModuleService.cs
    src/OpenAnima.Core/Services/ModuleService.cs
  </files>
  <action>
1. **PluginLoadContext.cs** — Change constructor from `base(isCollectible: false)` to `base(isCollectible: true)`. This enables `Unload()` to actually release the assembly. No other changes needed.

2. **PluginRegistry.cs** — Add `Unregister` method:
   ```csharp
   public bool Unregister(string moduleId)
   {
       if (_modules.TryRemove(moduleId, out var entry))
       {
           // Dispose module if it implements IDisposable
           if (entry.Module is IDisposable disposable)
               disposable.Dispose();
           // Unload the assembly context to free memory
           entry.Context.Unload();
           return true;
       }
       return false;
   }
   ```

3. **IModuleService.cs** — Add two new methods to the interface:
   ```csharp
   /// <summary>
   /// Unloads a module by name, removing it from registry.
   /// </summary>
   ModuleOperationResult UnloadModule(string moduleName);

   /// <summary>
   /// Gets names of module directories available to load (not yet loaded).
   /// </summary>
   IReadOnlyList<string> GetAvailableModules();
   ```

4. **ModuleService.cs** — Implement the two new methods:
   - `UnloadModule(string moduleName)`: Check `_registry.IsRegistered(moduleName)`, call `_registry.Unregister(moduleName)`, push `ReceiveModuleCountChanged` via `_hubContext`, return `ModuleOperationResult`. Wrap in try-catch, log errors, return failure result on exception.
   - `GetAvailableModules()`: Determine modules path as `Path.Combine(AppContext.BaseDirectory, "modules")`. If directory doesn't exist, return empty list. Get all subdirectory names, filter out names already in `_registry` (using `_registry.IsRegistered(name)`), return the remaining names.
   - Also push `ReceiveModuleCountChanged` in `UnloadModule` on success (fire-and-forget pattern matching existing `LoadModule`).
  </action>
  <verify>
    Build compiles: `dotnet build src/OpenAnima.Core/`. Verify PluginLoadContext has `isCollectible: true`. Verify PluginRegistry has `Unregister` method. Verify IModuleService has `UnloadModule` and `GetAvailableModules`. Verify ModuleService implements both.
  </verify>
  <done>
    PluginLoadContext is collectible. PluginRegistry can unregister modules. ModuleService can unload modules and discover available ones. All existing functionality preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add client-to-server Hub methods for control operations</name>
  <files>
    src/OpenAnima.Core/Hubs/RuntimeHub.cs
  </files>
  <action>
Update RuntimeHub to inject `IModuleService` and `IHeartbeatService` via constructor, then add 5 public async methods:

```csharp
public class RuntimeHub : Hub<IRuntimeClient>
{
    private readonly IModuleService _moduleService;
    private readonly IHeartbeatService _heartbeatService;

    public RuntimeHub(IModuleService moduleService, IHeartbeatService heartbeatService)
    {
        _moduleService = moduleService;
        _heartbeatService = heartbeatService;
    }

    /// Client calls: hubConnection.InvokeAsync<List<string>>("GetAvailableModules")
    public List<string> GetAvailableModules()
    {
        return _moduleService.GetAvailableModules().ToList();
    }

    /// Client calls: hubConnection.InvokeAsync<ModuleOperationResult>("LoadModule", moduleName)
    public async Task<ModuleOperationResult> LoadModule(string moduleName)
    {
        var modulesPath = Path.Combine(AppContext.BaseDirectory, "modules", moduleName);
        var result = _moduleService.LoadModule(modulesPath);
        if (result.Success)
            await Clients.All.ReceiveModuleCountChanged(_moduleService.Count);
        return result;
    }

    /// Client calls: hubConnection.InvokeAsync<ModuleOperationResult>("UnloadModule", moduleName)
    public async Task<ModuleOperationResult> UnloadModule(string moduleName)
    {
        var result = _moduleService.UnloadModule(moduleName);
        if (result.Success)
            await Clients.All.ReceiveModuleCountChanged(_moduleService.Count);
        return result;
    }

    /// Client calls: hubConnection.InvokeAsync<bool>("StartHeartbeat")
    public async Task<bool> StartHeartbeat()
    {
        try
        {
            await _heartbeatService.StartAsync();
            await Clients.All.ReceiveHeartbeatStateChanged(true);
            return true;
        }
        catch
        {
            return false;
        }
    }

    /// Client calls: hubConnection.InvokeAsync<bool>("StopHeartbeat")
    public async Task<bool> StopHeartbeat()
    {
        try
        {
            await _heartbeatService.StopAsync();
            await Clients.All.ReceiveHeartbeatStateChanged(false);
            return true;
        }
        catch
        {
            return false;
        }
    }
}
```

Note: `LoadModule` takes a module name (directory name), constructs the full path using `AppContext.BaseDirectory + "modules"` (same pattern as `OpenAnimaHostedService`). The `ModuleService.LoadModule` already handles the full path. `UnloadModule` delegates to the new `ModuleService.UnloadModule`. Both broadcast state changes to all clients after success.

Add required `using` statements: `OpenAnima.Core.Services` for `IModuleService`, `IHeartbeatService`, `ModuleOperationResult`.
  </action>
  <verify>
    Build compiles: `dotnet build src/OpenAnima.Core/`. Verify RuntimeHub has all 5 methods: GetAvailableModules, LoadModule, UnloadModule, StartHeartbeat, StopHeartbeat. Verify constructor injects IModuleService and IHeartbeatService.
  </verify>
  <done>
    RuntimeHub exposes 5 client-callable methods. LoadModule/UnloadModule return ModuleOperationResult with success/error info. StartHeartbeat/StopHeartbeat return bool. All methods broadcast state changes to connected clients on success.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/OpenAnima.Core/` compiles without errors
2. PluginLoadContext constructor uses `isCollectible: true`
3. PluginRegistry has `Unregister(string moduleId)` method
4. IModuleService declares `UnloadModule` and `GetAvailableModules`
5. ModuleService implements both new methods
6. RuntimeHub has constructor injection of IModuleService + IHeartbeatService
7. RuntimeHub has 5 public methods: GetAvailableModules, LoadModule, UnloadModule, StartHeartbeat, StopHeartbeat
</verification>

<success_criteria>
- All backend control operations are implemented and compile
- Hub methods are callable by SignalR clients
- Module unload properly removes from registry and unloads AssemblyLoadContext
- Available module discovery scans modules directory excluding already-loaded
- Heartbeat start/stop delegates to IHeartbeatService
- State changes broadcast to all connected clients
</success_criteria>

<output>
After completion, create `.planning/phases/06-control-operations/06-01-SUMMARY.md`
</output>
