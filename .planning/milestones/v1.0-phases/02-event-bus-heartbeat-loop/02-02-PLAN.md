---
phase: 02-event-bus-heartbeat-loop
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/OpenAnima.Core/Runtime/HeartbeatLoop.cs
  - src/OpenAnima.Core/Program.cs
  - samples/SampleModule/SampleModule.cs
autonomous: true
requirements: [RUN-03, MOD-04]

must_haves:
  truths:
    - "Heartbeat executes every ~100ms (configurable) without noticeable CPU impact"
    - "Each tick dispatches pending events then calls module Tick methods"
    - "Overlapping ticks are skipped (anti-snowball)"
    - "Modules send and receive events through the bus during heartbeat"
    - "Event delivery between modules completes within single heartbeat cycle"
  artifacts:
    - path: "src/OpenAnima.Core/Runtime/HeartbeatLoop.cs"
      provides: "PeriodicTimer-based heartbeat with anti-snowball guard"
      contains: "class HeartbeatLoop"
      min_lines: 40
    - path: "src/OpenAnima.Core/Program.cs"
      provides: "End-to-end wiring of EventBus + HeartbeatLoop + modules"
      contains: "HeartbeatLoop"
    - path: "samples/SampleModule/SampleModule.cs"
      provides: "Sample module demonstrating event pub/sub via ITickable"
      contains: "ITickable"
  key_links:
    - from: "src/OpenAnima.Core/Runtime/HeartbeatLoop.cs"
      to: "src/OpenAnima.Core/Events/EventBus.cs"
      via: "Dispatches pending events each tick"
      pattern: "EventBus|IEventBus"
    - from: "src/OpenAnima.Core/Runtime/HeartbeatLoop.cs"
      to: "src/OpenAnima.Contracts/ITickable.cs"
      via: "Calls TickAsync on all ITickable modules"
      pattern: "ITickable|TickAsync"
    - from: "src/OpenAnima.Core/Program.cs"
      to: "src/OpenAnima.Core/Runtime/HeartbeatLoop.cs"
      via: "Creates and starts heartbeat loop"
      pattern: "HeartbeatLoop"
---

<objective>
Implement the heartbeat loop with PeriodicTimer and wire the complete event bus + heartbeat pipeline end-to-end with a working demo.

Purpose: The heartbeat is the runtime scheduler that drives the entire agent — dispatching events and ticking modules at a steady cadence. This plan completes Phase 2 by proving events flow between modules through the heartbeat cycle.
Output: HeartbeatLoop implementation, updated Program.cs with full pipeline, SampleModule demonstrating event pub/sub.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-event-bus-heartbeat-loop/02-CONTEXT.md
@.planning/phases/02-event-bus-heartbeat-loop/02-RESEARCH.md
@.planning/phases/02-event-bus-heartbeat-loop/02-01-SUMMARY.md
@src/OpenAnima.Core/Program.cs
@src/OpenAnima.Core/Plugins/PluginRegistry.cs
@samples/SampleModule/SampleModule.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement HeartbeatLoop with PeriodicTimer and anti-snowball guard</name>
  <files>
    src/OpenAnima.Core/Runtime/HeartbeatLoop.cs
  </files>
  <action>
1. Create `src/OpenAnima.Core/Runtime/HeartbeatLoop.cs`:
   - Class `HeartbeatLoop : IDisposable`
   - Constructor takes: `IEventBus eventBus`, `PluginRegistry registry`, `TimeSpan? interval = null` (default 100ms), `ILogger<HeartbeatLoop>? logger = null`
   - Private fields:
     - `PeriodicTimer _timer`
     - `SemaphoreSlim _tickLock = new(1, 1)` — anti-snowball guard
     - `CancellationTokenSource _cts` — for stopping the loop
     - `long _tickCount` — for diagnostics
     - `long _skippedCount` — tracks skipped ticks for monitoring
   - **StartAsync(CancellationToken ct)**:
     - Creates PeriodicTimer with configured interval
     - Starts the loop on a background task via Task.Run
     - Returns immediately (non-blocking)
   - **RunLoopAsync(CancellationToken ct)** (private):
     - `while (await _timer.WaitForNextTickAsync(ct))`
     - Try acquire `_tickLock.Wait(0)` — if fails, increment _skippedCount, log warning, continue (SKIP tick, don't stack)
     - In try/finally: ExecuteTickAsync, then release semaphore
     - Catch OperationCanceledException (expected on shutdown)
   - **ExecuteTickAsync(CancellationToken ct)** (private):
     - Step 1: Call `eventBus.FlushAsync(ct)` if EventBus has a pending event queue (or skip if EventBus dispatches immediately on publish)
     - Step 2: Get all modules from registry, filter to ITickable (using name-based type check for cross-context compatibility), call TickAsync on each
     - Use Task.WhenAll for parallel module ticking
     - Wrap each module tick in try/catch — one module failure must not crash others
     - Log tick duration for performance monitoring
   - **StopAsync()**: Cancel CTS, dispose timer
   - **Dispose()**: Dispose timer, semaphore, CTS
   - Properties: `long TickCount`, `long SkippedCount`, `bool IsRunning`

2. Important design notes per user decisions:
   - Tick is a SCHEDULER — only dispatches events and calls module Tick. No heavy work in the tick itself.
   - Anti-snowball: `_tickLock.Wait(0)` returns false immediately if locked → skip tick, log it.
   - Configurable interval via constructor parameter.

3. Verify: `dotnet build OpenAnima.slnx` compiles with 0 errors.
  </action>
  <verify>
    `dotnet build OpenAnima.slnx` succeeds. HeartbeatLoop.cs exists in Runtime/ directory. Contains PeriodicTimer, SemaphoreSlim, and TickAsync dispatch logic.
  </verify>
  <done>
    HeartbeatLoop runs at configurable interval (default 100ms), skips overlapping ticks, dispatches events and calls ITickable modules each cycle. Properly disposable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire end-to-end pipeline and update SampleModule for event demo</name>
  <files>
    src/OpenAnima.Core/Program.cs
    samples/SampleModule/SampleModule.cs
  </files>
  <action>
1. Update `samples/SampleModule/SampleModule.cs`:
   - Add `ITickable` implementation to SampleModule
   - In TickAsync: publish a heartbeat event every 10th tick (to avoid spam) using IEventBus
   - The module needs access to IEventBus — add a method `SetEventBus(IEventBus bus)` or accept it via a new `IModuleContext` parameter in InitializeAsync. Simplest approach: add an `IEventBus?` property that the host sets after loading.
   - Subscribe to its own event type in InitializeAsync to demonstrate round-trip
   - Log when events are received to prove the bus works
   - Keep it simple — this is a demo, not production logic

2. Update `src/OpenAnima.Core/Program.cs`:
   - Create EventBus instance
   - After loading modules, inject EventBus into modules that need it (check for a known interface or property)
   - Create HeartbeatLoop with EventBus, registry, and default 100ms interval
   - Start the heartbeat loop
   - Show tick count and event stats periodically or on exit
   - On shutdown (Enter key): stop heartbeat, shutdown modules, dispose resources
   - The flow should be:
     ```
     1. Create EventBus
     2. Load modules (existing code)
     3. Register modules (existing code)
     4. Inject EventBus into modules
     5. Start HeartbeatLoop
     6. Wait for user input
     7. Stop heartbeat
     8. Shutdown modules
     9. Dispose
     ```

3. Rebuild SampleModule: `dotnet publish samples/SampleModule -o modules/SampleModule`

4. Run and verify: `dotnet run --project src/OpenAnima.Core` should show:
   - Module loaded and registered
   - Heartbeat ticking (visible via SampleModule tick logs)
   - Events published and received through the bus
   - Clean shutdown on Enter

5. Verify: `dotnet build OpenAnima.slnx` compiles with 0 errors. Runtime demo works.
  </action>
  <verify>
    `dotnet build OpenAnima.slnx` succeeds. `dotnet run --project src/OpenAnima.Core` shows heartbeat ticking and events flowing between modules. SampleModule implements ITickable and publishes/receives events.
  </verify>
  <done>
    Complete end-to-end pipeline: EventBus created → modules loaded → heartbeat started → SampleModule ticks and publishes events → events dispatched to subscribers → clean shutdown. Heartbeat runs at ~100ms with anti-snowball protection.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build OpenAnima.slnx` — 0 errors
2. `dotnet run --project src/OpenAnima.Core` — heartbeat ticks visible, events flow
3. HeartbeatLoop skips overlapping ticks (anti-snowball)
4. SampleModule publishes events via IEventBus and receives them back
5. Clean shutdown: heartbeat stops, modules shut down, no hanging threads
6. Heartbeat interval is configurable (default 100ms)
</verification>

<success_criteria>
- Heartbeat loop runs at ~100ms intervals with <1% CPU idle impact
- Events published by one module are received by subscribers within the same or next tick
- Overlapping ticks are skipped, not stacked
- End-to-end demo proves the event bus and heartbeat work together
- All Phase 2 success criteria from ROADMAP met:
  1. Modules send and receive typed events through MediatR bus
  2. Code heartbeat executes every 100ms without noticeable CPU impact
  3. Event delivery between modules completes within single heartbeat cycle
</success_criteria>

<output>
After completion, create `.planning/phases/02-event-bus-heartbeat-loop/02-02-SUMMARY.md`
</output>
