---
phase: 01-core-plugin-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - OpenAnima.sln
  - src/OpenAnima.Contracts/OpenAnima.Contracts.csproj
  - src/OpenAnima.Contracts/IModule.cs
  - src/OpenAnima.Contracts/IModuleMetadata.cs
  - src/OpenAnima.Contracts/IModuleInput.cs
  - src/OpenAnima.Contracts/IModuleOutput.cs
  - src/OpenAnima.Core/OpenAnima.Core.csproj
autonomous: true
requirements:
  - MOD-02

must_haves:
  truths:
    - "IModule interface exists with Metadata property and InitializeAsync hook"
    - "IModuleMetadata interface declares Name, Version, Description as properties"
    - "Typed input/output marker interfaces exist for module port contracts"
    - "Contracts assembly compiles as a standalone class library"
    - "Core project references Contracts and compiles"
  artifacts:
    - path: "OpenAnima.sln"
      provides: "Solution file linking all projects"
    - path: "src/OpenAnima.Contracts/IModule.cs"
      provides: "Base module interface with Metadata + InitializeAsync"
      exports: ["IModule"]
    - path: "src/OpenAnima.Contracts/IModuleMetadata.cs"
      provides: "Module metadata contract"
      exports: ["IModuleMetadata"]
    - path: "src/OpenAnima.Contracts/IModuleInput.cs"
      provides: "Typed input marker interface"
      exports: ["IModuleInput<T>"]
    - path: "src/OpenAnima.Contracts/IModuleOutput.cs"
      provides: "Typed output marker interface"
      exports: ["IModuleOutput<T>"]
    - path: "src/OpenAnima.Core/OpenAnima.Core.csproj"
      provides: "Core runtime project referencing Contracts"
  key_links:
    - from: "src/OpenAnima.Core/OpenAnima.Core.csproj"
      to: "src/OpenAnima.Contracts/OpenAnima.Contracts.csproj"
      via: "ProjectReference"
      pattern: "ProjectReference.*OpenAnima\\.Contracts"
---

<objective>
Create the .NET solution structure with the shared Contracts assembly that defines all module interfaces, and scaffold the Core runtime project.

Purpose: Establishes the typed contract foundation that all modules implement and the Core runtime consumes. The Contracts assembly loads into the Default AssemblyLoadContext and is shared across all plugin contexts — this is the critical architectural boundary that prevents type identity mismatches.

Output: Compilable solution with OpenAnima.Contracts (class library) and OpenAnima.Core (console app or class library) projects.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-plugin-system/01-CONTEXT.md
@.planning/phases/01-core-plugin-system/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create solution and Contracts class library with module interfaces</name>
  <files>
    OpenAnima.sln
    src/OpenAnima.Contracts/OpenAnima.Contracts.csproj
    src/OpenAnima.Contracts/IModule.cs
    src/OpenAnima.Contracts/IModuleMetadata.cs
    src/OpenAnima.Contracts/IModuleInput.cs
    src/OpenAnima.Contracts/IModuleOutput.cs
  </files>
  <action>
    Create the .NET solution and Contracts project:

    1. Run `dotnet new sln -n OpenAnima` in the repo root
    2. Run `dotnet new classlib -n OpenAnima.Contracts -o src/OpenAnima.Contracts --framework net8.0`
    3. Add project to solution: `dotnet sln add src/OpenAnima.Contracts`
    4. Delete the auto-generated Class1.cs

    Create the contract interfaces (per user decision: metadata via interface properties, NOT attributes):

    **IModuleMetadata.cs** — Declares module identity:
    - `string Name { get; }` — unique module name
    - `string Version { get; }` — semver string
    - `string Description { get; }` — human-readable description

    **IModule.cs** — Base module contract:
    - `IModuleMetadata Metadata { get; }` — module identity
    - `Task InitializeAsync(CancellationToken cancellationToken = default)` — called automatically on load (per user decision: Initialize hook called on load)
    - `Task ShutdownAsync(CancellationToken cancellationToken = default)` — clean teardown hook

    **IModuleInput&lt;T&gt;** — Generic marker interface for typed input ports:
    - `Task ProcessAsync(T input, CancellationToken cancellationToken = default)`
    - A module implementing `IModuleInput&lt;ChatMessage&gt;` declares it accepts ChatMessage inputs

    **IModuleOutput&lt;T&gt;** — Generic marker interface for typed output ports:
    - `event Func&lt;T, CancellationToken, Task&gt;? OnOutput`
    - A module implementing `IModuleOutput&lt;ChatResponse&gt;` declares it produces ChatResponse outputs
    - This event-based pattern prepares for Phase 2 event bus wiring (per user decision: hybrid sync+async model)

    All interfaces in namespace `OpenAnima.Contracts`. Target net8.0. No external NuGet dependencies.
  </action>
  <verify>
    Run `dotnet build src/OpenAnima.Contracts` — must compile with 0 errors.
    Verify all 4 interface files exist with correct signatures.
  </verify>
  <done>
    Contracts assembly compiles. IModule has Metadata property and InitializeAsync. IModuleMetadata has Name/Version/Description properties. IModuleInput&lt;T&gt; and IModuleOutput&lt;T&gt; provide typed port contracts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Scaffold Core runtime project with Contracts reference</name>
  <files>
    src/OpenAnima.Core/OpenAnima.Core.csproj
  </files>
  <action>
    Create the Core project that will host the plugin system:

    1. Run `dotnet new console -n OpenAnima.Core -o src/OpenAnima.Core --framework net8.0`
    2. Add to solution: `dotnet sln add src/OpenAnima.Core`
    3. Add project reference: `dotnet add src/OpenAnima.Core reference src/OpenAnima.Contracts`
    4. Delete auto-generated boilerplate in Program.cs, replace with minimal placeholder:
       ```csharp
       // OpenAnima Core Runtime — plugin system entry point
       Console.WriteLine("OpenAnima Core starting...");
       ```

    The Core project is where PluginLoadContext, PluginLoader, and PluginRegistry will live (Plan 01-02 and 01-03). This task just scaffolds the project with the correct reference.
  </action>
  <verify>
    Run `dotnet build` from solution root — both projects compile with 0 errors.
    Verify OpenAnima.Core.csproj contains ProjectReference to OpenAnima.Contracts.
  </verify>
  <done>
    Solution builds cleanly. Core project references Contracts. Ready for plugin loading infrastructure in Plan 01-02.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build OpenAnima.sln` completes with 0 errors, 0 warnings (or only informational)
2. `src/OpenAnima.Contracts/` contains IModule.cs, IModuleMetadata.cs, IModuleInput.cs, IModuleOutput.cs
3. `src/OpenAnima.Core/OpenAnima.Core.csproj` has ProjectReference to Contracts
4. No external NuGet packages — all built-in .NET APIs only
</verification>

<success_criteria>
- Solution compiles end-to-end
- All contract interfaces define the typed module system foundation
- Core project is scaffolded and ready for plugin loading code
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-plugin-system/01-01-SUMMARY.md`
</output>
