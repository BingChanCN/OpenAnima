---
phase: 01-core-plugin-system
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/OpenAnima.Core/Plugins/PluginRegistry.cs
  - samples/SampleModule/SampleModule.csproj
  - samples/SampleModule/SampleModule.cs
  - samples/SampleModule/module.json
  - src/OpenAnima.Core/Program.cs
autonomous: true
requirements:
  - MOD-05

must_haves:
  truths:
    - "Module registry tracks all loaded modules and exposes their metadata"
    - "Registry can look up modules by name and list all loaded modules"
    - "A sample module implementing IModule loads successfully from the modules directory"
    - "Multiple modules load in isolation without interfering with each other"
    - "End-to-end flow works: drop module folder -> auto-detect -> load -> register -> query"
  artifacts:
    - path: "src/OpenAnima.Core/Plugins/PluginRegistry.cs"
      provides: "In-memory registry for loaded modules"
      exports: ["PluginRegistry", "PluginRegistryEntry"]
    - path: "samples/SampleModule/SampleModule.cs"
      provides: "Reference module implementation proving the contract works"
      exports: ["SampleModule"]
    - path: "samples/SampleModule/module.json"
      provides: "Example manifest file"
    - path: "src/OpenAnima.Core/Program.cs"
      provides: "Wired entry point that scans, loads, and registers modules"
  key_links:
    - from: "src/OpenAnima.Core/Plugins/PluginRegistry.cs"
      to: "src/OpenAnima.Core/Plugins/PluginLoader.cs"
      via: "Registers LoadResult modules"
      pattern: "Register.*IModule|PluginRegistryEntry"
    - from: "src/OpenAnima.Core/Program.cs"
      to: "src/OpenAnima.Core/Plugins/PluginLoader.cs"
      via: "Calls ScanDirectory then registers results"
      pattern: "ScanDirectory|LoadModule"
    - from: "src/OpenAnima.Core/Program.cs"
      to: "src/OpenAnima.Core/Plugins/PluginRegistry.cs"
      via: "Registers and queries modules"
      pattern: "PluginRegistry|GetAllModules|Register"
    - from: "samples/SampleModule/SampleModule.cs"
      to: "src/OpenAnima.Contracts/IModule.cs"
      via: "Implements IModule interface"
      pattern: "class SampleModule.*IModule"
---

<objective>
Implement the module registry, create a sample module that proves the contract works, and wire everything together in Program.cs for end-to-end verification.

Purpose: Completes the plugin system by adding the registry (MOD-05) and proving the entire pipeline works: module folder detection -> manifest parsing -> isolated loading -> initialization -> registry query. The sample module serves as both a verification tool and a reference implementation for module developers.

Output: Working plugin system that loads a sample module from disk and displays it in the registry.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-plugin-system/01-CONTEXT.md
@.planning/phases/01-core-plugin-system/01-RESEARCH.md
@.planning/phases/01-core-plugin-system/01-01-SUMMARY.md
@.planning/phases/01-core-plugin-system/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PluginRegistry and create sample module</name>
  <files>
    src/OpenAnima.Core/Plugins/PluginRegistry.cs
    samples/SampleModule/SampleModule.csproj
    samples/SampleModule/SampleModule.cs
    samples/SampleModule/module.json
  </files>
  <action>
    **PluginRegistry.cs** — In-memory module registry:

    Namespace: `OpenAnima.Core.Plugins`

    - `PluginRegistryEntry` record: `IModule Module`, `PluginLoadContext Context`, `PluginManifest Manifest`, `DateTime LoadedAt`
    - `Register(string moduleId, IModule module, PluginLoadContext context, PluginManifest manifest)`:
      - Stores entry keyed by moduleId (use manifest.Name as ID)
      - If moduleId already registered, throw descriptive exception (duplicate detection)
    - `GetModule(string moduleId) -> IModule?` — lookup by name
    - `GetEntry(string moduleId) -> PluginRegistryEntry?` — full entry with metadata
    - `GetAllModules() -> IReadOnlyList&lt;PluginRegistryEntry&gt;` — all loaded modules
    - `IsRegistered(string moduleId) -> bool`
    - `Count` property — number of loaded modules
    - Thread-safe: use `ConcurrentDictionary&lt;string, PluginRegistryEntry&gt;` since watcher callbacks may register concurrently

    **Sample module** — Reference implementation:

    Create `samples/SampleModule/SampleModule.csproj`:
    - Target net8.0, class library
    - Reference OpenAnima.Contracts via ProjectReference (for development; published modules would reference the NuGet package)
    - Add to solution: `dotnet sln add samples/SampleModule`

    Create `samples/SampleModule/SampleModule.cs`:
    - Class `SampleModule : IModule`
    - Metadata returns name="SampleModule", version="1.0.0", description="A sample module for testing the plugin system"
    - `InitializeAsync` logs "SampleModule initialized" to Console and returns CompletedTask
    - Implement a simple `IModuleInput&lt;string&gt;` that writes received input to Console (demonstrates typed input port)

    Create `samples/SampleModule/module.json`:
    ```json
    {
      "name": "SampleModule",
      "version": "1.0.0",
      "description": "A sample module for testing the plugin system",
      "entryAssembly": "SampleModule.dll"
    }
    ```

    Build and publish the sample module to a local modules directory for testing:
    - `dotnet publish samples/SampleModule -o modules/SampleModule`
    - This generates the .deps.json that AssemblyDependencyResolver needs
  </action>
  <verify>
    `dotnet build OpenAnima.sln` compiles all 3 projects with 0 errors.
    `dotnet publish samples/SampleModule -o modules/SampleModule` succeeds.
    `modules/SampleModule/` contains SampleModule.dll, SampleModule.deps.json, and module.json.
  </verify>
  <done>
    PluginRegistry provides thread-safe module storage and lookup. SampleModule implements IModule with metadata properties and InitializeAsync. Published module folder contains DLL + deps.json + manifest.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Program.cs for end-to-end module loading and registry display</name>
  <files>
    src/OpenAnima.Core/Program.cs
  </files>
  <action>
    Update Program.cs to demonstrate the full plugin pipeline:

    1. Create `PluginRegistry` instance
    2. Create `PluginLoader` instance
    3. Define modules directory path: `Path.Combine(AppContext.BaseDirectory, "modules")` or `./modules/` relative to working directory (per user decision: single fixed module directory)
    4. Call `loader.ScanDirectory(modulesPath)` to discover and load all modules
    5. For each successful LoadResult: register in PluginRegistry
    6. For each failed LoadResult: print error details to Console (per user decision: load failures prompt user with error details)
    7. Print registry summary: "Loaded {count} module(s):"
    8. For each registered module: print Name, Version, Description
    9. Create `ModuleDirectoryWatcher` watching the modules directory
    10. Wire watcher callback to load + register new modules
    11. Print "Watching for new modules in {path}... Press Enter to exit."
    12. `Console.ReadLine()` to keep process alive for watcher demo
    13. Dispose watcher on exit

    This creates a runnable demo: `dotnet run --project src/OpenAnima.Core` should:
    - Find SampleModule in modules/
    - Load it in isolated context
    - Call InitializeAsync (prints "SampleModule initialized")
    - Register it
    - Display registry listing
    - Watch for new modules
  </action>
  <verify>
    Run `dotnet run --project src/OpenAnima.Core` from repo root (after publishing SampleModule to modules/).
    Expected output includes:
    - "SampleModule initialized"
    - Registry listing showing SampleModule with version 1.0.0
    - "Watching for new modules" message
    Verify no unhandled exceptions.
  </verify>
  <done>
    End-to-end pipeline works: scan directory -> parse manifest -> load in isolated context -> initialize -> register -> display. Watcher active for hot discovery. Load failures display descriptive errors.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build OpenAnima.sln` compiles all projects (Contracts, Core, SampleModule) with 0 errors
2. `dotnet publish samples/SampleModule -o modules/SampleModule` produces DLL + deps.json
3. `dotnet run --project src/OpenAnima.Core` loads SampleModule, prints initialization message, displays registry
4. PluginRegistry.GetAllModules() returns the loaded SampleModule with correct metadata
5. SampleModule loads in its own AssemblyLoadContext (not Default)
6. ModuleDirectoryWatcher is active and watching for new module directories
</verification>

<success_criteria>
- Complete plugin system works end-to-end from directory scan to registry display
- Sample module proves the contract interfaces work correctly
- Registry exposes all loaded modules with their capabilities
- System is ready for Phase 2 (event bus wiring between modules)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-plugin-system/01-03-SUMMARY.md`
</output>
