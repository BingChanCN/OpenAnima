---
phase: 16-module-runtime-initialization-port-registration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/OpenAnima.Core/Hosting/WiringInitializationService.cs
  - src/OpenAnima.Core/Components/Pages/Editor.razor
  - tests/OpenAnima.Tests/Integration/ModuleRuntimeInitializationTests.cs
autonomous: true
requirements:
  - PORT-04
  - RMOD-01
  - RMOD-02
  - RMOD-03
  - RMOD-04
  - EDIT-01

must_haves:
  truths:
    - "All 4 concrete module ports (LLMModule, ChatInputModule, ChatOutputModule, HeartbeatModule) are registered in IPortRegistry after app startup"
    - "Module palette shows real modules instead of demo modules (TextInput, LLMProcessor, TextOutput, TriggerButton are gone)"
    - "LLMModule and ChatOutputModule have active EventBus subscriptions after startup (InitializeAsync called)"
    - "Port registration completes before config loading in the startup sequence"
  artifacts:
    - path: "src/OpenAnima.Core/Hosting/WiringInitializationService.cs"
      provides: "Port discovery, registration, and module initialization at startup"
      contains: "DiscoverPorts"
    - path: "src/OpenAnima.Core/Components/Pages/Editor.razor"
      provides: "Editor page without demo module fallback"
    - path: "tests/OpenAnima.Tests/Integration/ModuleRuntimeInitializationTests.cs"
      provides: "Integration tests for startup port registration and module initialization"
      min_lines: 80
  key_links:
    - from: "WiringInitializationService.StartAsync"
      to: "PortDiscovery.DiscoverPorts + IPortRegistry.RegisterPorts"
      via: "Resolves singletons from IServiceProvider"
      pattern: "portDiscovery\\.DiscoverPorts.*portRegistry\\.RegisterPorts"
    - from: "WiringInitializationService.StartAsync"
      to: "IModuleExecutor.InitializeAsync"
      via: "Resolves module singletons and calls InitializeAsync"
      pattern: "module\\.InitializeAsync"
    - from: "Editor.razor"
      to: "IPortRegistry"
      via: "No longer calls RegisterDemoModules — registry already populated at startup"
---

<objective>
Wire concrete modules (LLMModule, ChatInputModule, ChatOutputModule, HeartbeatModule) into the runtime startup sequence so their ports are discovered, registered, and modules initialized before the app accepts requests.

Purpose: Close the gap where modules exist as singletons in DI but their ports are never registered and InitializeAsync is never called at runtime. This makes the editor palette show real modules and enables module EventBus subscriptions.

Output: Modified WiringInitializationService with port discovery + module init, cleaned Editor.razor without demo fallback, integration tests proving the behavior.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/16-module-runtime-initialization-port-registration/16-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/OpenAnima.Core/Ports/PortDiscovery.cs:
```csharp
public class PortDiscovery
{
    public List<PortMetadata> DiscoverPorts(Type moduleType)
}
```

From src/OpenAnima.Core/Ports/IPortRegistry.cs:
```csharp
public interface IPortRegistry
{
    void RegisterPorts(string moduleName, List<PortMetadata> ports);
    List<PortMetadata> GetPorts(string moduleName);
    List<PortMetadata> GetAllPorts();
    void UnregisterPorts(string moduleName);
}
```

From src/OpenAnima.Contracts/IModuleExecutor.cs (extends IModule):
```csharp
public interface IModuleExecutor : IModule
{
    Task ExecuteAsync(CancellationToken ct = default);
    ModuleExecutionState GetState();
    Exception? GetLastError();
}
```

From src/OpenAnima.Contracts/IModule.cs (IModule has InitializeAsync):
```csharp
public interface IModule
{
    IModuleMetadata Metadata { get; }
    Task InitializeAsync(CancellationToken ct = default);
    Task ShutdownAsync(CancellationToken ct = default);
}
```

From src/OpenAnima.Core/DependencyInjection/WiringServiceExtensions.cs (module DI registrations):
```csharp
services.AddSingleton<LLMModule>();          // OpenAnima.Core.Modules
services.AddSingleton<ChatInputModule>();    // OpenAnima.Core.Modules
services.AddSingleton<ChatOutputModule>();   // OpenAnima.Core.Modules
services.AddSingleton<HeartbeatModule>();    // OpenAnima.Core.Modules
services.AddSingleton<IPortRegistry, PortRegistry>();
services.AddSingleton<PortDiscovery>();
services.AddHostedService<WiringInitializationService>();
```

Current WiringInitializationService.StartAsync (to be extended):
```csharp
public async Task StartAsync(CancellationToken cancellationToken)
{
    // Currently: only loads last config from .lastconfig file
    // Gap: never calls PortDiscovery or InitializeAsync on modules
}
```

Current Editor.razor demo fallback (to be removed):
```csharp
if (_portRegistry.GetAllPorts().Count == 0)
{
    RegisterDemoModules(); // Registers TextInput, LLMProcessor, TextOutput, TriggerButton
}
```

Module name convention: `moduleType.Name` == `module.Metadata.Name` for all 4 modules.
Port event naming: `{ModuleName}.port.{portName}` (e.g., "LLMModule.port.prompt").
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend WiringInitializationService and remove demo fallback</name>
  <files>
    src/OpenAnima.Core/Hosting/WiringInitializationService.cs
    src/OpenAnima.Core/Components/Pages/Editor.razor
  </files>
  <action>
Modify `WiringInitializationService.StartAsync()` to perform three steps IN THIS ORDER before the existing config-loading logic:

**Step 1 — Register ports for all concrete modules:**
Add a private method `RegisterModulePorts()` that:
1. Resolves `PortDiscovery` and `IPortRegistry` from `_serviceProvider` (both are singletons, no scope needed)
2. Iterates over the 4 module types: `typeof(LLMModule)`, `typeof(ChatInputModule)`, `typeof(ChatOutputModule)`, `typeof(HeartbeatModule)`
3. For each type, calls `portDiscovery.DiscoverPorts(moduleType)` and `portRegistry.RegisterPorts(moduleType.Name, ports)`
4. Wraps each iteration in try/catch — log warning and skip on failure (matches Phase 12.5 pattern: "Skip module with warning instead of blocking entire load operation")
5. Logs `"Registered {Count} ports for {Module}"` on success

**Step 2 — Initialize all concrete modules:**
Add a private async method `InitializeModulesAsync(CancellationToken)` that:
1. Resolves each module singleton from `_serviceProvider`: `GetRequiredService<LLMModule>()`, etc.
2. Casts each to `IModuleExecutor` (they all implement it)
3. Calls `module.InitializeAsync(cancellationToken)` on each
4. Wraps each in try/catch — log warning and skip on failure
5. Logs `"Initialized module: {Module}"` using `module.Metadata.Name` on success

**Step 3 — Call both methods at the TOP of StartAsync:**
```csharp
public async Task StartAsync(CancellationToken cancellationToken)
{
    // Phase 16: Register ports and initialize modules BEFORE loading config
    RegisterModulePorts();
    await InitializeModulesAsync(cancellationToken);

    // Existing config-loading logic follows unchanged...
    var lastConfigPath = Path.Combine(_configDirectory, ".lastconfig");
    // ...
}
```

Add required `using` statements:
- `using OpenAnima.Core.Modules;` (for LLMModule, ChatInputModule, etc.)
- `using OpenAnima.Core.Ports;` (for PortDiscovery, IPortRegistry)
- `using OpenAnima.Contracts;` (for IModuleExecutor)

**Editor.razor cleanup:**
1. Remove the entire `if (_portRegistry.GetAllPorts().Count == 0) { RegisterDemoModules(); }` block from `OnInitialized()`
2. Remove the entire `RegisterDemoModules()` method (lines 47-73 approximately)
3. Keep the comment about subscribing to state changes and the config loading logic intact

Do NOT modify WiringServiceExtensions.cs — all DI registrations are already correct.
  </action>
  <verify>
    <automated>dotnet build /home/user/OpenAnima/src/OpenAnima.Core/ -q --no-restore</automated>
  </verify>
  <done>
    WiringInitializationService.StartAsync calls RegisterModulePorts() then InitializeModulesAsync() before config loading.
    Editor.razor no longer contains RegisterDemoModules or the empty-registry guard.
    Project compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests for module runtime initialization</name>
  <files>
    tests/OpenAnima.Tests/Integration/ModuleRuntimeInitializationTests.cs
  </files>
  <action>
Create `tests/OpenAnima.Tests/Integration/ModuleRuntimeInitializationTests.cs` with integration tests that verify the startup behavior. Follow the pattern from `WiringDIIntegrationTests.cs`: build a real DI container with `ServiceCollection` + `AddWiringServices()`, use temp config directory, dispose properly.

**Test class setup:**
```csharp
public class ModuleRuntimeInitializationTests : IDisposable
{
    private readonly ServiceProvider _provider;
    private readonly string _tempConfigDir;

    public ModuleRuntimeInitializationTests()
    {
        _tempConfigDir = Path.Combine(Path.GetTempPath(), $"module-init-test-{Guid.NewGuid()}");
        Directory.CreateDirectory(_tempConfigDir);

        var services = new ServiceCollection();
        services.AddLogging(builder => builder.AddConsole().SetMinimumLevel(LogLevel.Warning));
        services.AddSingleton<EventBus>();
        services.AddSingleton<IEventBus>(sp => sp.GetRequiredService<EventBus>());
        services.AddWiringServices(_tempConfigDir);
        _provider = services.BuildServiceProvider();
    }
}
```

**Test 1: `WiringInitializationService_RegistersAllModulePorts`** (covers PORT-04, RMOD-01, RMOD-02, RMOD-03, RMOD-04)
- Resolve `WiringInitializationService` from `_provider.GetRequiredService<IHostedService>()` — it's registered via `AddHostedService`, so resolve as `IEnumerable<IHostedService>` and find the `WiringInitializationService` instance
- Call `StartAsync(CancellationToken.None)`
- Resolve `IPortRegistry` and verify:
  - `GetPorts("LLMModule")` returns 2 ports (prompt input, response output)
  - `GetPorts("ChatInputModule")` returns 1 port (userMessage output)
  - `GetPorts("ChatOutputModule")` returns 1 port (displayText input)
  - `GetPorts("HeartbeatModule")` returns 1 port (tick output)
- All tests use `[Trait("Category", "Integration")]`

**Test 2: `WiringInitializationService_InitializesModules_EventBusSubscriptionsActive`** (covers RMOD-01, RMOD-03)
- Call `StartAsync` on the hosted service
- Resolve `IEventBus` from provider
- Publish a text event to `"LLMModule.port.prompt"` — this verifies LLMModule's InitializeAsync set up its EventBus subscription
- NOTE: LLMModule will try to call the LLM API which will fail. That's OK — the test only needs to verify the subscription exists. Use a TaskCompletionSource with short timeout (1 second) on `"LLMModule.port.response"` to check if the module attempted to process. If it throws (no API key), that still proves the subscription is active. Alternatively, verify ChatOutputModule by publishing to `"ChatOutputModule.port.displayText"` and checking its `OnMessageReceived` event fires.
- Simpler approach: Resolve `ChatOutputModule` singleton, subscribe to its `OnMessageReceived` event, publish to `"ChatOutputModule.port.displayText"`, verify the callback fires within 5 seconds.

**Test 3: `PortRegistry_HasRealModules_NotDemoModules`** (covers EDIT-01)
- Call `StartAsync` on the hosted service
- Resolve `IPortRegistry`
- Call `GetAllPorts()` and verify:
  - Contains ports with ModuleName "LLMModule", "ChatInputModule", "ChatOutputModule", "HeartbeatModule"
  - Does NOT contain ports with ModuleName "TextInput", "LLMProcessor", "TextOutput", "TriggerButton" (the old demo modules)

Use `using` statements matching `WiringDIIntegrationTests.cs` pattern plus:
- `using OpenAnima.Core.Hosting;` for WiringInitializationService
- `using OpenAnima.Core.Modules;` for ChatOutputModule
- `using Microsoft.Extensions.Hosting;` for IHostedService
  </action>
  <verify>
    <automated>dotnet test /home/user/OpenAnima/tests/OpenAnima.Tests/ -q --filter "FullyQualifiedName~ModuleRuntimeInitialization"</automated>
  </verify>
  <done>
    3 integration tests pass: port registration for all 4 modules, EventBus subscription active after init, real modules in registry (no demo modules).
    All tests use [Trait("Category", "Integration")] for filtering.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build /home/user/OpenAnima/ -q` — full solution compiles
2. `dotnet test /home/user/OpenAnima/tests/OpenAnima.Tests/ -q --filter "FullyQualifiedName~ModuleRuntimeInitialization"` — all 3 new tests pass
3. `dotnet test /home/user/OpenAnima/tests/OpenAnima.Tests/ -q` — full suite green (no regressions)
</verification>

<success_criteria>
- WiringInitializationService.StartAsync discovers and registers ports for LLMModule, ChatInputModule, ChatOutputModule, HeartbeatModule
- WiringInitializationService.StartAsync calls InitializeAsync on each module singleton
- Port registration happens BEFORE config loading in StartAsync
- Editor.razor no longer contains RegisterDemoModules or the empty-registry fallback
- IPortRegistry contains real module ports (not demo modules) after startup
- All existing tests continue passing
</success_criteria>

<output>
After completion, create `.planning/phases/16-module-runtime-initialization-port-registration/16-01-SUMMARY.md`
</output>
