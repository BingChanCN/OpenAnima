---
phase: 01-core-plugin-system
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/OpenAnima.Core/Plugins/PluginLoadContext.cs
  - src/OpenAnima.Core/Plugins/PluginManifest.cs
  - src/OpenAnima.Core/Plugins/PluginLoader.cs
  - src/OpenAnima.Core/Plugins/ModuleDirectoryWatcher.cs
autonomous: true
requirements:
  - MOD-01
  - MOD-03

must_haves:
  truths:
    - "Plugin DLL loads into isolated AssemblyLoadContext separate from Default context"
    - "Plugin dependencies resolve automatically from .deps.json without manual setup"
    - "Dropping a module folder into ./modules/ triggers automatic detection and loading"
    - "module.json manifest is parsed for module metadata"
    - "Load failures produce descriptive error messages, not silent skips"
  artifacts:
    - path: "src/OpenAnima.Core/Plugins/PluginLoadContext.cs"
      provides: "Custom AssemblyLoadContext with AssemblyDependencyResolver"
      exports: ["PluginLoadContext"]
    - path: "src/OpenAnima.Core/Plugins/PluginManifest.cs"
      provides: "JSON manifest model and parser"
      exports: ["PluginManifest"]
    - path: "src/OpenAnima.Core/Plugins/PluginLoader.cs"
      provides: "Assembly loading, type discovery, module instantiation"
      exports: ["PluginLoader"]
    - path: "src/OpenAnima.Core/Plugins/ModuleDirectoryWatcher.cs"
      provides: "FileSystemWatcher with debouncing for hot discovery"
      exports: ["ModuleDirectoryWatcher"]
  key_links:
    - from: "src/OpenAnima.Core/Plugins/PluginLoader.cs"
      to: "src/OpenAnima.Core/Plugins/PluginLoadContext.cs"
      via: "Creates PluginLoadContext per plugin"
      pattern: "new PluginLoadContext"
    - from: "src/OpenAnima.Core/Plugins/PluginLoader.cs"
      to: "src/OpenAnima.Contracts/IModule.cs"
      via: "Discovers types implementing IModule"
      pattern: "typeof\\(IModule\\)\\.IsAssignableFrom"
    - from: "src/OpenAnima.Core/Plugins/ModuleDirectoryWatcher.cs"
      to: "src/OpenAnima.Core/Plugins/PluginLoader.cs"
      via: "Calls loader on new directory detection"
      pattern: "PluginLoader.*Load|OnModuleDiscovered"
---

<objective>
Implement the plugin loading infrastructure: isolated AssemblyLoadContext per plugin, manifest parsing, assembly discovery and instantiation, and FileSystemWatcher-based hot discovery.

Purpose: This is the core of MOD-01 (assembly isolation) and MOD-03 (zero-config installation). Plugins load into their own AssemblyLoadContext with automatic dependency resolution, and new modules are detected when dropped into the modules directory.

Output: Four classes in OpenAnima.Core/Plugins/ that handle the full load lifecycle from directory detection to module instantiation.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-plugin-system/01-CONTEXT.md
@.planning/phases/01-core-plugin-system/01-RESEARCH.md
@.planning/phases/01-core-plugin-system/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PluginLoadContext and PluginManifest</name>
  <files>
    src/OpenAnima.Core/Plugins/PluginLoadContext.cs
    src/OpenAnima.Core/Plugins/PluginManifest.cs
  </files>
  <action>
    **PluginLoadContext.cs** — Custom AssemblyLoadContext with isolation:

    Namespace: `OpenAnima.Core.Plugins`

    - Constructor takes `string pluginPath` (path to the plugin DLL)
    - Creates `AssemblyDependencyResolver` from pluginPath for automatic dependency resolution from .deps.json
    - Override `Load(AssemblyName assemblyName)`:
      - Use resolver to get assembly path
      - If path found, call `LoadFromAssemblyPath(path)`
      - If null, return null (falls back to Default context — this is how shared Contracts stay in Default, preventing type identity mismatch)
    - Override `LoadUnmanagedDll(string unmanagedDllName)`:
      - Use resolver to get native library path
      - If found, call `LoadUnmanagedDllFromPath(path)`
      - If null, return IntPtr.Zero
    - Pass `isCollectible: false` to base constructor (unloading deferred to Phase 7)
    - Follow the exact pattern from Microsoft's official plugin tutorial

    **PluginManifest.cs** — JSON manifest model:

    Namespace: `OpenAnima.Core.Plugins`

    - Properties: `Name` (string, required), `Version` (string, required), `Description` (string, optional), `EntryAssembly` (string, required — DLL filename without path)
    - Static method `LoadFromDirectory(string moduleDirectory)`:
      - Looks for `module.json` in the directory
      - Deserializes using System.Text.Json with case-insensitive property matching
      - Throws descriptive exception if file missing or malformed (per user decision: load failures prompt user with error details)
    - Use `System.Text.Json.JsonSerializerOptions` with `PropertyNameCaseInsensitive = true`
    - Use `[JsonPropertyName]` attributes for explicit mapping
  </action>
  <verify>
    `dotnet build src/OpenAnima.Core` compiles with 0 errors.
    PluginLoadContext inherits AssemblyLoadContext and overrides Load + LoadUnmanagedDll.
    PluginManifest has LoadFromDirectory static method.
  </verify>
  <done>
    PluginLoadContext provides per-plugin isolation with automatic dependency resolution. PluginManifest parses module.json with clear error messages on failure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement PluginLoader and ModuleDirectoryWatcher</name>
  <files>
    src/OpenAnima.Core/Plugins/PluginLoader.cs
    src/OpenAnima.Core/Plugins/ModuleDirectoryWatcher.cs
  </files>
  <action>
    **PluginLoader.cs** — Assembly loading and module instantiation:

    Namespace: `OpenAnima.Core.Plugins`

    - `LoadResult` record: `IModule? Module`, `PluginLoadContext? Context`, `PluginManifest? Manifest`, `Exception? Error`, `bool Success`
    - Method `LoadModule(string moduleDirectory) -> LoadResult`:
      1. Parse manifest via `PluginManifest.LoadFromDirectory(moduleDirectory)`
      2. Resolve DLL path: `Path.Combine(moduleDirectory, manifest.EntryAssembly)`
      3. Verify DLL exists — return error LoadResult if not (descriptive message)
      4. Create `new PluginLoadContext(dllPath)`
      5. Load assembly: `context.LoadFromAssemblyName(new AssemblyName(...))`
      6. Scan types for `typeof(IModule).IsAssignableFrom(type) && !type.IsInterface && !type.IsAbstract`
      7. Instantiate via `Activator.CreateInstance(type) as IModule`
      8. Call `module.InitializeAsync()` (per user decision: Initialize hook called automatically on load)
      9. Return success LoadResult with module, context, manifest
      10. Wrap entire flow in try/catch — return error LoadResult on any exception (never throw, never silently skip)
    - Method `ScanDirectory(string modulesPath) -> IReadOnlyList&lt;LoadResult&gt;`:
      - Enumerate subdirectories in modulesPath
      - Call LoadModule for each
      - Return all results (successes and failures — caller decides how to handle)

    **ModuleDirectoryWatcher.cs** — Hot discovery with debouncing:

    Namespace: `OpenAnima.Core.Plugins`

    - Constructor takes `string modulesPath` and `Action&lt;string&gt; onModuleDiscovered` callback
    - Uses `FileSystemWatcher` monitoring modulesPath:
      - `NotifyFilter = NotifyFilters.DirectoryName` (watch for new directories only)
      - `IncludeSubdirectories = false`
    - On `Created` event: debounce with 500ms `System.Threading.Timer` to let file operations complete
    - After debounce: invoke `onModuleDiscovered(fullPath)` callback
    - Track discovered paths in `HashSet&lt;string&gt;` to prevent duplicate loads
    - `StartWatching()` method: creates modules directory if not exists, enables watcher
    - `StopWatching()` method: disables watcher, disposes timer
    - Implements `IDisposable` for cleanup
    - Manual refresh: `RefreshAll()` method that re-scans directory and invokes callback for any new (untracked) directories
  </action>
  <verify>
    `dotnet build src/OpenAnima.Core` compiles with 0 errors.
    PluginLoader.LoadModule returns LoadResult with either Module or Error populated.
    ModuleDirectoryWatcher creates FileSystemWatcher with debouncing.
  </verify>
  <done>
    PluginLoader loads modules from directories with full error handling. ModuleDirectoryWatcher provides hot discovery with debouncing and duplicate prevention. Manual RefreshAll available as fallback.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build OpenAnima.sln` compiles with 0 errors
2. PluginLoadContext overrides Load() returning null for unknown assemblies (falls back to Default context)
3. PluginLoader.LoadModule wraps all errors in LoadResult (never throws)
4. ModuleDirectoryWatcher debounces FileSystemWatcher events with 500ms timer
5. No external NuGet packages — all built-in .NET APIs
</verification>

<success_criteria>
- All four plugin infrastructure classes compile and follow the patterns from RESEARCH.md
- Load errors produce descriptive messages (not silent failures)
- FileSystemWatcher monitors for new module directories with debouncing
- Assembly isolation uses AssemblyDependencyResolver for automatic dependency resolution
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-plugin-system/01-02-SUMMARY.md`
</output>
