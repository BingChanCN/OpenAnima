---
phase: 13-visual-drag-and-drop-editor
plan: 03
type: execute
wave: 3
depends_on: ["13-02"]
files_modified:
  - src/OpenAnima.Core/Services/EditorStateService.cs
  - src/OpenAnima.Core/Components/Pages/Editor.razor.cs
  - src/OpenAnima.Core/Components/Shared/EditorCanvas.razor
  - tests/OpenAnima.Tests/Unit/EditorStateServiceTests.cs
autonomous: false
requirements:
  - EDIT-04
  - EDIT-05
  - EDIT-06

must_haves:
  truths:
    - "User can click a node to select it (highlighted border) and press Delete to remove it and its connections"
    - "User can click a connection to select it (thicker stroke) and press Delete to remove it"
    - "User can save the current wiring configuration and reload it with all nodes and connections restored"
    - "Editor auto-saves configuration after any change (add/remove/move) without manual action"
  artifacts:
    - path: "src/OpenAnima.Core/Services/EditorStateService.cs"
      provides: "Selection state, deletion logic, auto-save debounce, save/load integration"
    - path: "tests/OpenAnima.Tests/Unit/EditorStateServiceTests.cs"
      provides: "Unit tests for selection, deletion, and state management logic"
      min_lines: 50
  key_links:
    - from: "EditorStateService"
      to: "IConfigurationLoader"
      via: "SaveAsync/LoadAsync for persistence"
      pattern: "IConfigurationLoader.*SaveAsync|LoadAsync"
    - from: "EditorStateService"
      to: "IWiringEngine"
      via: "LoadConfiguration after save to keep engine in sync"
      pattern: "IWiringEngine.*LoadConfiguration"
    - from: "Editor.razor.cs"
      to: "EditorStateService"
      via: "Keyboard event handler calls DeleteSelected on Delete key"
      pattern: "DeleteSelected|KeyDown.*Delete"
---

<objective>
Add selection/deletion, keyboard shortcuts, save/load integration, and auto-save. Users can select nodes and connections, delete them with the Delete key, and configurations auto-save after changes. Includes unit tests for EditorStateService logic and a visual checkpoint.

Purpose: Completes the editor's interactive capabilities and connects it to the persistence layer.
Output: Fully interactive editor with selection, deletion, persistence, and auto-save.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-visual-drag-and-drop-editor/13-CONTEXT.md
@.planning/phases/13-visual-drag-and-drop-editor/13-02-SUMMARY.md

@src/OpenAnima.Core/Services/EditorStateService.cs
@src/OpenAnima.Core/Components/Pages/Editor.razor.cs
@src/OpenAnima.Core/Components/Shared/EditorCanvas.razor

<interfaces>
From IConfigurationLoader:
```csharp
Task SaveAsync(WiringConfiguration config, CancellationToken ct = default);
Task<WiringConfiguration> LoadAsync(string configName, CancellationToken ct = default);
ValidationResult ValidateConfiguration(WiringConfiguration config);
List<string> ListConfigurations();
```

From IWiringEngine:
```csharp
bool IsLoaded { get; }
WiringConfiguration? GetCurrentConfiguration();
void LoadConfiguration(WiringConfiguration config);
void UnloadConfiguration();
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add selection, deletion, keyboard shortcuts, save/load, and auto-save</name>
  <files>
    src/OpenAnima.Core/Services/EditorStateService.cs
    src/OpenAnima.Core/Components/Pages/Editor.razor.cs
    src/OpenAnima.Core/Components/Shared/EditorCanvas.razor
  </files>
  <action>
1. Selection logic in EditorStateService (may already be partially scaffolded from Plan 01):
   - `SelectNode(string moduleId, bool addToSelection = false)`: if !addToSelection, clear all selections first. Add moduleId to SelectedNodeIds. Fire OnStateChanged.
   - `SelectConnection(string srcModuleId, string srcPort, string tgtModuleId, string tgtPort, bool addToSelection = false)`: similar, using a connection key string.
   - `ClearSelection()`: clear both sets, fire OnStateChanged.
   - `DeleteSelected()`: for each selected node, remove from Configuration.Nodes and remove all connections involving that node from Configuration.Connections. For each selected connection, remove from Configuration.Connections. Clear selection. Fire OnStateChanged. Trigger auto-save.

2. Keyboard handling in Editor.razor.cs:
   - Add `@onkeydown="HandleKeyDown"` on the editor container div (needs tabindex="0" to receive keyboard events).
   - `HandleKeyDown(KeyboardEventArgs e)`:
     - If e.Key == "Delete" or e.Key == "Backspace": call `_editorState.DeleteSelected()`
     - If e.Key == "Escape": call `_editorState.ClearSelection()`
   - Click on canvas background: call `_editorState.ClearSelection()` (deselect all)

3. Auto-save with debounce in EditorStateService:
   - Add `IConfigurationLoader` and `IWiringEngine` as constructor dependencies (injected via DI)
   - Private `CancellationTokenSource? _autoSaveDebounce`
   - `async void TriggerAutoSave()`: cancel previous debounce, create new CTS, await Task.Delay(500ms, token), then call `await _configLoader.SaveAsync(Configuration)` and `_wiringEngine.LoadConfiguration(Configuration)`. Wrap in try-catch (ignore OperationCanceledException from debounce, log other errors).
   - Call TriggerAutoSave() from: AddNode, RemoveNode, RemoveConnection, DeleteSelected, EndNodeDrag (position change), EndConnectionDrag (new connection created).
   - Configuration name: use "default" or derive from existing loaded config name.

4. Save/load UI integration in Editor.razor.cs:
   - On initialization: if `_wiringEngine.IsLoaded`, set `_editorState.Configuration = _wiringEngine.GetCurrentConfiguration()`. Otherwise start empty with `new WiringConfiguration { Name = "default" }`.
   - The auto-save handles ongoing persistence. Manual save/load not needed as a separate UI element — auto-save covers EDIT-06, and the configuration persists via ConfigurationLoader (EDIT-05). The WiringInitializationService auto-loads on app restart.

5. Wire selection visuals:
   - In EditorCanvas, pass `IsSelected` parameter to NodeCard based on `_editorState.SelectedNodeIds.Contains(node.ModuleId)`
   - In EditorCanvas, pass `IsSelected` parameter to ConnectionLine based on `_editorState.SelectedConnectionIds.Contains(connectionKey)`
   - NodeCard onclick (on background rect, not ports): call `_editorState.SelectNode(Node.ModuleId, e.ShiftKey)` for shift-click multi-select
   - ConnectionLine invisible hit path onclick: call `_editorState.SelectConnection(...)`
  </action>
  <verify>
    <automated>cd /home/user/OpenAnima && dotnet build src/OpenAnima.Core/OpenAnima.Core.csproj --no-restore 2>&1 | tail -5</automated>
  </verify>
  <done>Clicking nodes/connections selects them with visual feedback. Delete key removes selected items. Auto-save triggers 500ms after any change. Configuration persists via ConfigurationLoader and reloads on app restart via WiringInitializationService.</done>
</task>

<task type="auto">
  <name>Task 2: Add EditorStateService unit tests</name>
  <files>
    tests/OpenAnima.Tests/Unit/EditorStateServiceTests.cs
  </files>
  <action>
1. Create `EditorStateServiceTests.cs` with xUnit tests covering EditorStateService logic:
   - Use mock/stub IConfigurationLoader and IWiringEngine (or create minimal test doubles since these are interfaces). Can use simple in-memory implementations or NSubstitute if already in test project — check existing test patterns first.

2. Test cases:
   - `AddNode_CreatesNodeAtPosition`: call AddNode("TestModule", 100, 200), verify Configuration.Nodes has 1 node with correct ModuleName and Position.
   - `AddNode_GeneratesUniqueModuleId`: add two nodes, verify different ModuleIds.
   - `RemoveNode_RemovesNodeAndConnections`: add 2 nodes, add connection between them, remove first node, verify node gone AND connection gone.
   - `SelectNode_SetsSelection`: select a node, verify IsNodeSelected returns true.
   - `SelectNode_ClearsOtherSelection`: select node A, then select node B without addToSelection, verify only B selected.
   - `SelectNode_ShiftAddsToSelection`: select node A, then select node B with addToSelection=true, verify both selected.
   - `DeleteSelected_RemovesSelectedNodes`: add 2 nodes, select first, call DeleteSelected, verify only second remains.
   - `DeleteSelected_RemovesSelectedConnections`: add connection, select it, delete, verify connections empty.
   - `ClearSelection_ClearsAll`: select node and connection, clear, verify nothing selected.
   - `ScreenToCanvas_AppliesInverseTransform`: set Scale=2, PanX=100, PanY=50, verify ScreenToCanvas(300, 250) returns (100, 100).
   - `OnStateChanged_FiresOnModification`: subscribe to event, add node, verify event fired.

3. Follow existing test patterns in the project (check tests/OpenAnima.Tests/ for conventions — likely xUnit with [Fact] attributes).
  </action>
  <verify>
    <automated>cd /home/user/OpenAnima && dotnet test tests/OpenAnima.Tests/ --filter "FullyQualifiedName~EditorStateService" --no-restore 2>&1 | tail -10</automated>
  </verify>
  <done>11+ unit tests pass covering node CRUD, selection, deletion, coordinate transforms, and state change events.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete visual editor end-to-end</name>
  <files>N/A</files>
  <action>Human verifies the complete visual drag-and-drop editor works end-to-end by testing all interactive features in the browser.</action>
  <verify>Human confirms all 12 verification steps pass</verify>
  <done>Editor approved by user after visual and functional verification</done>
  <what-built>Complete visual drag-and-drop editor with: SVG canvas (pan/zoom), module palette (drag-to-add), node cards (Unreal Blueprint style with colored ports), bezier curve connections (drag from output to input), selection (click nodes/connections), deletion (Delete key), and auto-save persistence.</what-built>
  <how-to-verify>
    1. Run the app: `cd /home/user/OpenAnima && dotnet run --project src/OpenAnima.Core`
    2. Navigate to http://localhost:5000/editor (or whatever port)
    3. Verify the editor page loads with SVG canvas on left and module palette on right
    4. Try pan: drag the canvas background — canvas should pan smoothly
    5. Try zoom: scroll mouse wheel — canvas should zoom centered on cursor
    6. Drag a module from the palette onto the canvas — a node card should appear at drop location
    7. Drag another module onto the canvas
    8. Drag from an output port (right side circle) to an input port (left side circle) — should see dashed bezier preview, then solid connection on drop
    9. Click a node — should show highlighted border (accent color)
    10. Press Delete — selected node and its connections should disappear
    11. Refresh the page — configuration should auto-reload (nodes and connections restored)
    12. Verify dark theme matches rest of application
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. `dotnet build` succeeds
2. `dotnet test` — all tests pass including new EditorStateService tests
3. Selection visual feedback works (highlighted border on nodes, thicker stroke on connections)
4. Delete key removes selected items
5. Auto-save persists configuration after changes
6. Configuration reloads on page refresh / app restart
</verification>

<success_criteria>
- Clicking nodes shows selection highlight, clicking connections shows selection highlight
- Delete key removes selected nodes (and their connections) and selected connections
- Auto-save triggers after add/remove/move operations (500ms debounce)
- Configuration persists and reloads on refresh
- 11+ unit tests pass for EditorStateService
- Human verifies complete editor flow works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/13-visual-drag-and-drop-editor/13-03-SUMMARY.md`
</output>
