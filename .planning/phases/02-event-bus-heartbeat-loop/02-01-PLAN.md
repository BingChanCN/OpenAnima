---
phase: 02-event-bus-heartbeat-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/OpenAnima.Core/OpenAnima.Core.csproj
  - src/OpenAnima.Contracts/IEventBus.cs
  - src/OpenAnima.Contracts/ModuleEvent.cs
  - src/OpenAnima.Contracts/ITickable.cs
  - src/OpenAnima.Core/Events/EventBus.cs
  - src/OpenAnima.Core/Events/EventSubscription.cs
autonomous: true
requirements: [MOD-04]

must_haves:
  truths:
    - "Modules can publish typed events with metadata (timestamp, source, event ID)"
    - "Modules can subscribe to events at runtime with optional filters"
    - "Modules can unsubscribe from events at runtime"
    - "Broadcast events reach all matching subscribers"
    - "Targeted messages support request-response between specific modules"
  artifacts:
    - path: "src/OpenAnima.Contracts/ModuleEvent.cs"
      provides: "Generic event wrapper with metadata"
      contains: "class ModuleEvent"
    - path: "src/OpenAnima.Contracts/IEventBus.cs"
      provides: "Event bus contract for modules"
      exports: ["IEventBus"]
    - path: "src/OpenAnima.Contracts/ITickable.cs"
      provides: "Interface for modules that participate in heartbeat"
      exports: ["ITickable"]
    - path: "src/OpenAnima.Core/Events/EventBus.cs"
      provides: "MediatR-backed event bus with dynamic subscription"
      exports: ["EventBus"]
    - path: "src/OpenAnima.Core/Events/EventSubscription.cs"
      provides: "Subscription handle for unsubscribe support"
      exports: ["EventSubscription"]
  key_links:
    - from: "src/OpenAnima.Core/Events/EventBus.cs"
      to: "MediatR IMediator"
      via: "Publish/Send delegation"
      pattern: "_mediator\\.Publish"
    - from: "src/OpenAnima.Contracts/IEventBus.cs"
      to: "src/OpenAnima.Contracts/ModuleEvent.cs"
      via: "Publish accepts ModuleEvent"
      pattern: "ModuleEvent"
---

<objective>
Implement the event bus infrastructure: MediatR integration, generic event wrapper with metadata, and dynamic subscription/unsubscription with conditional filtering.

Purpose: Enable inter-module communication through typed events with runtime subscription management — the messaging backbone for all module interactions.
Output: Event contracts in Contracts assembly, EventBus implementation in Core wrapping MediatR with dynamic handler management.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-event-bus-heartbeat-loop/02-CONTEXT.md
@.planning/phases/02-event-bus-heartbeat-loop/02-RESEARCH.md
@.planning/phases/01-core-plugin-system/01-01-SUMMARY.md
@.planning/phases/01-core-plugin-system/01-03-SUMMARY.md
@src/OpenAnima.Contracts/IModule.cs
@src/OpenAnima.Contracts/IModuleInput.cs
@src/OpenAnima.Contracts/IModuleOutput.cs
@src/OpenAnima.Core/OpenAnima.Core.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MediatR and create event contracts in Contracts assembly</name>
  <files>
    src/OpenAnima.Core/OpenAnima.Core.csproj
    src/OpenAnima.Contracts/ModuleEvent.cs
    src/OpenAnima.Contracts/IEventBus.cs
    src/OpenAnima.Contracts/ITickable.cs
  </files>
  <action>
1. Add MediatR NuGet package to OpenAnima.Core:
   `dotnet add src/OpenAnima.Core package MediatR --version 12.*`
   (Use v12 which includes DI registration built-in via AddMediatR — v14 renamed the package but v12 is the stable widely-used version for .NET 8)

2. Create `src/OpenAnima.Contracts/ModuleEvent.cs`:
   - Generic class `ModuleEvent<TPayload>` implementing MediatR `INotification`
   - NOTE: Contracts assembly must NOT reference MediatR. Instead, define a marker interface `IModuleEvent` in Contracts, and have the Core-side adapter implement INotification.
   - Actually, per user decision: modules define own event types, not centralized in Contracts. So the event wrapper goes in Contracts as a POCO (no MediatR dependency):
     ```
     public class ModuleEvent<TPayload>
     {
         public string EventName { get; init; }
         public TPayload Payload { get; set; }  // Mutable per user decision
         public string SourceModuleId { get; init; }
         public DateTime Timestamp { get; init; }
         public Guid EventId { get; init; }
         public bool IsHandled { get; set; }  // Handlers can mark as handled
     }
     ```
   - Also create non-generic base `ModuleEvent` with the metadata properties (EventName, SourceModuleId, Timestamp, EventId, IsHandled) for type-erased scenarios.

3. Create `src/OpenAnima.Contracts/IEventBus.cs`:
   - Interface `IEventBus` with methods:
     - `Task PublishAsync<TPayload>(ModuleEvent<TPayload> evt, CancellationToken ct = default)` — broadcast
     - `Task<TResponse> SendAsync<TResponse>(string targetModuleId, object request, CancellationToken ct = default)` — targeted request-response
     - `IDisposable Subscribe<TPayload>(string eventName, Func<ModuleEvent<TPayload>, CancellationToken, Task> handler, Func<ModuleEvent<TPayload>, bool>? filter = null)` — returns disposable subscription handle
     - `IDisposable Subscribe<TPayload>(Func<ModuleEvent<TPayload>, CancellationToken, Task> handler, Func<ModuleEvent<TPayload>, bool>? filter = null)` — subscribe to all events of payload type (no name filter)
   - Keep this interface in Contracts so modules can depend on it without referencing Core.

4. Create `src/OpenAnima.Contracts/ITickable.cs`:
   - Interface `ITickable` with single method: `Task TickAsync(CancellationToken ct = default)`
   - Modules implementing this get called every heartbeat cycle.
   - Keep in Contracts so modules can opt-in.

5. Verify: `dotnet build OpenAnima.slnx` compiles with 0 errors.
  </action>
  <verify>
    `dotnet build OpenAnima.slnx` succeeds with 0 errors. All 3 new files exist in Contracts. MediatR package present in Core .csproj.
  </verify>
  <done>
    ModuleEvent generic wrapper has all metadata fields (EventName, Payload, SourceModuleId, Timestamp, EventId). IEventBus defines publish/subscribe/send. ITickable defines TickAsync. MediatR added to Core.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement EventBus with MediatR backend and dynamic subscription</name>
  <files>
    src/OpenAnima.Core/Events/EventBus.cs
    src/OpenAnima.Core/Events/EventSubscription.cs
  </files>
  <action>
1. Create `src/OpenAnima.Core/Events/EventSubscription.cs`:
   - Internal class representing an active subscription.
   - Properties: Id (Guid), EventName (string?, null = all events of type), PayloadType (Type), Handler (Delegate), Filter (Delegate?), IsActive (bool).
   - Implements IDisposable — Dispose sets IsActive = false and removes from parent EventBus subscription list.

2. Create `src/OpenAnima.Core/Events/EventBus.cs`:
   - Class `EventBus : IEventBus`
   - Internal subscription storage: `ConcurrentDictionary<Type, ConcurrentBag<EventSubscription>>` keyed by payload type.
   - **PublishAsync<TPayload>**: Iterate all subscriptions for TPayload type. For each active subscription: check eventName match (if subscription has name filter), check predicate filter, invoke handler. Use Task.WhenAll for parallel handler execution. Catch and log individual handler exceptions without stopping other handlers.
   - **SendAsync<TResponse>**: For targeted module-to-module request-response. Maintain a separate `ConcurrentDictionary<string, Func<object, CancellationToken, Task<object>>>` for request handlers keyed by targetModuleId. Throw if no handler registered for target.
   - **Subscribe<TPayload>**: Create EventSubscription, add to bag for TPayload type, return the subscription (which is IDisposable). When subscription disposed, mark inactive.
   - **RegisterRequestHandler(string moduleId, Func<...> handler)**: For request-response registration.
   - Do NOT rebuild the DI container for dynamic subscriptions — use internal handler list instead of MediatR's handler discovery. MediatR is used only for its IMediator.Publish pipeline if needed, but the primary dispatch is through the internal subscription list for dynamic runtime flexibility.
   - Thread safety: ConcurrentDictionary + ConcurrentBag for lock-free reads. Periodically clean up disposed subscriptions on publish (lazy cleanup).
   - Constructor takes ILogger<EventBus> for logging handler errors and subscription lifecycle.

3. Verify: `dotnet build OpenAnima.slnx` compiles with 0 errors. EventBus implements IEventBus.
  </action>
  <verify>
    `dotnet build OpenAnima.slnx` succeeds. EventBus class exists in Events/ directory and implements IEventBus. EventSubscription implements IDisposable.
  </verify>
  <done>
    EventBus supports: publish with parallel handler dispatch, subscribe with optional name + predicate filters, unsubscribe via IDisposable, targeted request-response. All thread-safe with ConcurrentDictionary.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build OpenAnima.slnx` — 0 errors, 0 warnings
2. Contracts assembly has: ModuleEvent.cs, IEventBus.cs, ITickable.cs
3. Core assembly has: Events/EventBus.cs, Events/EventSubscription.cs
4. MediatR package referenced in Core .csproj
5. No MediatR dependency in Contracts .csproj (Contracts stays dependency-free)
</verification>

<success_criteria>
- Event bus infrastructure compiles and is ready for heartbeat integration
- Modules can be written against IEventBus and ITickable contracts
- Dynamic subscription/unsubscription works without DI container rebuild
- Event metadata (timestamp, source, ID) automatically populated
</success_criteria>

<output>
After completion, create `.planning/phases/02-event-bus-heartbeat-loop/02-01-SUMMARY.md`
</output>
