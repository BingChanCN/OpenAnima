---
phase: 12.5-runtime-di-integration-tech-debt-fix
plan: 03
type: tdd
wave: 2
depends_on: ["12.5-01"]
files_modified:
  - tests/OpenAnima.Tests/Integration/WiringDIIntegrationTests.cs
autonomous: true
requirements:
  - PORT-04
  - WIRE-01
  - WIRE-02
  - WIRE-03
  - EDIT-03
  - EDIT-05
  - EDIT-06
  - E2E-01

must_haves:
  truths:
    - "IWiringEngine resolves from DI container with scoped lifetime"
    - "IConfigurationLoader resolves from DI container and can save/load configs"
    - "IPortRegistry resolves from DI container and stores port metadata"
    - "PortRegistry is populated and queryable after port registration"
    - "ConfigurationLoader saves .lastconfig file after save operation"
    - "WiringEngine loads configuration and executes modules in topological order via DI"
    - "Cycle detection works when WiringEngine is resolved from DI"
    - "Data routing works when WiringEngine is resolved from DI"
  artifacts:
    - path: "tests/OpenAnima.Tests/Integration/WiringDIIntegrationTests.cs"
      provides: "Integration tests for DI registration, port registration, config lifecycle, and runtime execution"
      min_lines: 100
  key_links:
    - from: "tests/OpenAnima.Tests/Integration/WiringDIIntegrationTests.cs"
      to: "src/OpenAnima.Core/DependencyInjection/WiringServiceExtensions.cs"
      via: "Tests call AddWiringServices() to build real DI container"
      pattern: "AddWiringServices"
---

<objective>
Create integration tests that verify all DI registrations work correctly: service resolution, port registration flow, configuration save/load with last-config tracking, and WiringEngine runtime execution through DI.

Purpose: Prove that Phase 12.5 DI integration works end-to-end, covering all 8 requirement IDs. Tests use real DI container (not mocks) to catch lifetime and resolution issues.
Output: Single integration test file covering DI resolution, port registration, config lifecycle, and execution flow.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12.5-runtime-di-integration-tech-debt-fix/12.5-01-SUMMARY.md

<interfaces>
<!-- Interfaces from Plan 01 — tests verify these resolve correctly from DI -->

From src/OpenAnima.Core/Ports/IPortRegistry.cs:
```csharp
public interface IPortRegistry
{
    void RegisterPorts(string moduleName, List<PortMetadata> ports);
    List<PortMetadata> GetPorts(string moduleName);
    List<PortMetadata> GetAllPorts();
    void UnregisterPorts(string moduleName);
}
```

From src/OpenAnima.Core/Wiring/IConfigurationLoader.cs:
```csharp
public interface IConfigurationLoader
{
    Task SaveAsync(WiringConfiguration config, CancellationToken ct = default);
    Task<WiringConfiguration> LoadAsync(string configName, CancellationToken ct = default);
    ValidationResult ValidateConfiguration(WiringConfiguration config);
    List<string> ListConfigurations();
    Task DeleteAsync(string configName, CancellationToken ct = default);
}
```

From src/OpenAnima.Core/Wiring/IWiringEngine.cs:
```csharp
public interface IWiringEngine
{
    bool IsLoaded { get; }
    WiringConfiguration? GetCurrentConfiguration();
    void LoadConfiguration(WiringConfiguration config);
    Task ExecuteAsync(CancellationToken ct = default);
    void UnloadConfiguration();
}
```

From src/OpenAnima.Core/DependencyInjection/WiringServiceExtensions.cs:
```csharp
public static IServiceCollection AddWiringServices(this IServiceCollection services, string? configDirectory = null)
```

Existing test pattern from tests/OpenAnima.Tests/Integration/:
- Uses xUnit 2.9.3
- Integration tests use [Trait("Category", "Integration")]
- Tests create real service instances (not mocks)
- EventBus created fresh per test for isolation
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WiringDIIntegrationTests with DI resolution and runtime flow tests</name>
  <files>
    tests/OpenAnima.Tests/Integration/WiringDIIntegrationTests.cs
  </files>
  <action>
    Create integration test file using real DI container (ServiceCollection + BuildServiceProvider). Use a temp directory for config files (cleaned up in Dispose).

    Test class setup:
    - Implements `IDisposable`
    - Creates `ServiceCollection`, registers `AddLogging()`, `AddSingleton<EventBus>()`, `AddSingleton<IEventBus>(sp => sp.GetRequiredService<EventBus>())`, then `AddWiringServices(tempConfigDir)`
    - Builds `ServiceProvider`
    - Creates scope for each test via `_provider.CreateScope()`
    - Dispose cleans up temp directory and provider

    Required test cases (each with `[Trait("Category", "Integration")]`):

    **DI Resolution (PORT-04, WIRE-01, WIRE-02, WIRE-03, EDIT-03, EDIT-05):**
    1. `IPortRegistry_ResolvesFromDI` — resolve IPortRegistry from scope, assert not null, assert is PortRegistry type
    2. `IWiringEngine_ResolvesFromDI` — resolve IWiringEngine from scope, assert not null
    3. `IConfigurationLoader_ResolvesFromDI` — resolve IConfigurationLoader from scope, assert not null
    4. `ScopedServices_DifferentPerScope` — create two scopes, resolve IPortRegistry from each, assert they are different instances (scoped lifetime verification)

    **Port Registration Flow (PORT-04, EDIT-03):**
    5. `PortRegistry_RegisterAndQuery` — resolve IPortRegistry, register ports for a test module, query back, assert ports match. Verifies PortRegistry is populated and queryable for editor.

    **Configuration Lifecycle (EDIT-05, EDIT-06):**
    6. `ConfigurationLoader_SaveAndLoad` — resolve IConfigurationLoader, create a WiringConfiguration, save it, load it back, assert name and nodes match
    7. `ConfigurationLoader_SaveWritesLastConfig` — resolve IConfigurationLoader, save a config, assert `.lastconfig` file exists in temp dir with correct config name
    8. `ConfigurationLoader_ListConfigurations` — save two configs, call ListConfigurations(), assert both names returned

    **WiringEngine Runtime (WIRE-01, WIRE-02, WIRE-03, E2E-01):**
    9. `WiringEngine_LoadAndExecute` — resolve IWiringEngine and IPortRegistry, register ports for two test modules, create config with A→B connection, load config, execute, assert IsLoaded is true and no exception thrown
    10. `WiringEngine_CycleDetection` — resolve IWiringEngine and IPortRegistry, register ports, create config with A→B→A cycle, assert LoadConfiguration throws InvalidOperationException with cycle message
    11. `WiringEngine_DataRouting` — resolve IWiringEngine, IPortRegistry, and IEventBus, register ports, create config with A→B connection, load config, subscribe to target port event, publish to source port, assert data arrives at target (use TaskCompletionSource with 5s timeout)

    For test modules, create simple PortMetadata lists directly (no need for actual module classes):
    ```csharp
    var portsA = new List<PortMetadata>
    {
        new("Output", PortType.Text, PortDirection.Output, "ModuleA")
    };
    var portsB = new List<PortMetadata>
    {
        new("Input", PortType.Text, PortDirection.Input, "ModuleB")
    };
    ```

    For WiringConfiguration in tests:
    ```csharp
    var config = new WiringConfiguration
    {
        Name = "test-config",
        Nodes = new List<ModuleNode>
        {
            new() { ModuleId = "ModuleA", ModuleName = "ModuleA" },
            new() { ModuleId = "ModuleB", ModuleName = "ModuleB" }
        },
        Connections = new List<PortConnection>
        {
            new()
            {
                SourceModuleId = "ModuleA", SourcePortName = "Output",
                TargetModuleId = "ModuleB", TargetPortName = "Input"
            }
        }
    };
    ```
  </action>
  <verify>
    <automated>cd /home/user/OpenAnima && dotnet test --filter "FullyQualifiedName~WiringDIIntegrationTests" --no-build 2>&1 | tail -15</automated>
  </verify>
  <done>All 11 integration tests pass, covering DI resolution (4), port registration (1), config lifecycle (3), and runtime execution (3)</done>
</task>

</tasks>

<verification>
1. `dotnet test --filter "FullyQualifiedName~WiringDIIntegrationTests"` — all 11 tests pass
2. `dotnet test` — full suite passes (no regressions)
3. Tests use real DI container, not mocks
4. Tests cover all 8 requirement IDs
5. Temp directories cleaned up after tests
</verification>

<success_criteria>
- 11 integration tests pass covering all requirement IDs
- Tests use real ServiceCollection + AddWiringServices() (not mocks)
- Scoped lifetime verified (different instances per scope)
- Port registration, config save/load, last-config tracking all verified
- WiringEngine execution, cycle detection, and data routing verified through DI
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/12.5-runtime-di-integration-tech-debt-fix/12.5-03-SUMMARY.md`
</output>
