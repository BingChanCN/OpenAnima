---
phase: 12.5-runtime-di-integration-tech-debt-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/OpenAnima.Core/Wiring/IWiringEngine.cs
  - src/OpenAnima.Core/Wiring/IConfigurationLoader.cs
  - src/OpenAnima.Core/Ports/IPortRegistry.cs
  - src/OpenAnima.Core/Wiring/WiringEngine.cs
  - src/OpenAnima.Core/Wiring/ConfigurationLoader.cs
  - src/OpenAnima.Core/Ports/PortRegistry.cs
  - src/OpenAnima.Core/DependencyInjection/WiringServiceExtensions.cs
  - src/OpenAnima.Core/Program.cs
autonomous: true
requirements:
  - PORT-04
  - WIRE-01
  - WIRE-02
  - WIRE-03
  - EDIT-03
  - EDIT-05
  - EDIT-06

must_haves:
  truths:
    - "WiringEngine is resolvable from DI container via IWiringEngine interface"
    - "ConfigurationLoader is resolvable from DI container via IConfigurationLoader interface"
    - "PortRegistry is resolvable from DI container via IPortRegistry interface"
    - "All three services use scoped lifetime (per-circuit in Blazor Server)"
    - "AddWiringServices() is a single-line call in Program.cs"
  artifacts:
    - path: "src/OpenAnima.Core/Wiring/IWiringEngine.cs"
      provides: "Interface contract for WiringEngine"
      exports: ["IWiringEngine"]
    - path: "src/OpenAnima.Core/Wiring/IConfigurationLoader.cs"
      provides: "Interface contract for ConfigurationLoader"
      exports: ["IConfigurationLoader"]
    - path: "src/OpenAnima.Core/Ports/IPortRegistry.cs"
      provides: "Interface contract for PortRegistry"
      exports: ["IPortRegistry"]
    - path: "src/OpenAnima.Core/DependencyInjection/WiringServiceExtensions.cs"
      provides: "Extension method for DI registration"
      exports: ["AddWiringServices"]
  key_links:
    - from: "src/OpenAnima.Core/DependencyInjection/WiringServiceExtensions.cs"
      to: "src/OpenAnima.Core/Program.cs"
      via: "builder.Services.AddWiringServices()"
      pattern: "AddWiringServices"
    - from: "src/OpenAnima.Core/Wiring/WiringEngine.cs"
      to: "src/OpenAnima.Core/Wiring/IWiringEngine.cs"
      via: "class implements interface"
      pattern: "class WiringEngine.*IWiringEngine"
---

<objective>
Extract interfaces from WiringEngine, ConfigurationLoader, and PortRegistry; create AddWiringServices() extension method; register all services in DI container via Program.cs.

Purpose: Make Phase 11/12 services available at runtime through DI, unblocking Blazor components and future phases (13, 14) from injecting these services.
Output: Three interface files, updated concrete classes implementing interfaces, extension method, and Program.cs registration.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/OpenAnima.Core/Wiring/WiringEngine.cs:
```csharp
public class WiringEngine
{
    public WiringEngine(IEventBus eventBus, PortRegistry portRegistry, ILogger<WiringEngine> logger)
    public bool IsLoaded => _currentConfig != null;
    public WiringConfiguration? GetCurrentConfiguration() => _currentConfig;
    public void LoadConfiguration(WiringConfiguration config)
    public async Task ExecuteAsync(CancellationToken ct = default)
    public void UnloadConfiguration()
}
```

From src/OpenAnima.Core/Wiring/ConfigurationLoader.cs:
```csharp
public class ConfigurationLoader
{
    public ConfigurationLoader(string configDirectory, PortRegistry portRegistry, PortTypeValidator portTypeValidator)
    public async Task SaveAsync(WiringConfiguration config, CancellationToken ct = default)
    public async Task<WiringConfiguration> LoadAsync(string configName, CancellationToken ct = default)
    public ValidationResult ValidateConfiguration(WiringConfiguration config)
    public List<string> ListConfigurations()
    public async Task DeleteAsync(string configName, CancellationToken ct = default)
}
```

From src/OpenAnima.Core/Ports/PortRegistry.cs:
```csharp
public class PortRegistry
{
    public void RegisterPorts(string moduleName, List<PortMetadata> ports)
    public List<PortMetadata> GetPorts(string moduleName)
    public List<PortMetadata> GetAllPorts()
    public void UnregisterPorts(string moduleName)
}
```

From src/OpenAnima.Core/Program.cs (registration section):
```csharp
// --- Register core runtime components as singletons ---
builder.Services.AddSingleton<PluginRegistry>();
builder.Services.AddSingleton<PluginLoader>();
builder.Services.AddSingleton<EventBus>();
builder.Services.AddSingleton<IEventBus>(sp => sp.GetRequiredService<EventBus>());
// ... (other registrations)
builder.Services.AddHostedService<OpenAnimaHostedService>();
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract interfaces and update concrete classes</name>
  <files>
    src/OpenAnima.Core/Wiring/IWiringEngine.cs
    src/OpenAnima.Core/Wiring/IConfigurationLoader.cs
    src/OpenAnima.Core/Ports/IPortRegistry.cs
    src/OpenAnima.Core/Wiring/WiringEngine.cs
    src/OpenAnima.Core/Wiring/ConfigurationLoader.cs
    src/OpenAnima.Core/Ports/PortRegistry.cs
  </files>
  <action>
    Create three interface files extracting public API from existing concrete classes:

    1. **IWiringEngine.cs** in `src/OpenAnima.Core/Wiring/`:
       - `bool IsLoaded { get; }`
       - `WiringConfiguration? GetCurrentConfiguration()`
       - `void LoadConfiguration(WiringConfiguration config)`
       - `Task ExecuteAsync(CancellationToken ct = default)`
       - `void UnloadConfiguration()`

    2. **IConfigurationLoader.cs** in `src/OpenAnima.Core/Wiring/`:
       - `Task SaveAsync(WiringConfiguration config, CancellationToken ct = default)`
       - `Task<WiringConfiguration> LoadAsync(string configName, CancellationToken ct = default)`
       - `ValidationResult ValidateConfiguration(WiringConfiguration config)`
       - `List<string> ListConfigurations()`
       - `Task DeleteAsync(string configName, CancellationToken ct = default)`

    3. **IPortRegistry.cs** in `src/OpenAnima.Core/Ports/`:
       - `void RegisterPorts(string moduleName, List<PortMetadata> ports)`
       - `List<PortMetadata> GetPorts(string moduleName)`
       - `List<PortMetadata> GetAllPorts()`
       - `void UnregisterPorts(string moduleName)`

    Then update the three concrete classes to implement their respective interfaces:
    - `public class WiringEngine : IWiringEngine`
    - `public class ConfigurationLoader : IConfigurationLoader`
    - `public class PortRegistry : IPortRegistry`

    Also update WiringEngine constructor to accept `IPortRegistry` instead of `PortRegistry`.
    Also update ConfigurationLoader constructor to accept `IPortRegistry` instead of `PortRegistry`.

    Update any existing test files that reference concrete types in constructor calls to use the concrete type still (tests don't use DI). The key change is the constructor parameter types.
  </action>
  <verify>
    <automated>cd /home/user/OpenAnima && dotnet build src/OpenAnima.Core/ --no-restore 2>&1 | tail -5</automated>
  </verify>
  <done>Three interface files exist, three concrete classes implement them, WiringEngine and ConfigurationLoader accept interface types in constructors, project compiles</done>
</task>

<task type="auto">
  <name>Task 2: Create AddWiringServices extension method and register in Program.cs</name>
  <files>
    src/OpenAnima.Core/DependencyInjection/WiringServiceExtensions.cs
    src/OpenAnima.Core/Program.cs
  </files>
  <action>
    1. Create `src/OpenAnima.Core/DependencyInjection/WiringServiceExtensions.cs`:
       - Namespace: `OpenAnima.Core.DependencyInjection`
       - Static class `WiringServiceExtensions` with extension method `AddWiringServices(this IServiceCollection services, string? configDirectory = null)`
       - Default configDirectory: `Path.Combine(AppContext.BaseDirectory, "wiring-configs")`
       - Call `Directory.CreateDirectory(configDirectory)` to ensure it exists
       - Register scoped services per user decision:
         - `services.AddScoped<IPortRegistry, PortRegistry>()`
         - `services.AddScoped<PortTypeValidator>()` (needed by ConfigurationLoader)
         - `services.AddScoped<PortDiscovery>()` (needed by ModuleService for port registration)
         - `services.AddScoped<IConfigurationLoader>(sp => new ConfigurationLoader(configDirectory, sp.GetRequiredService<IPortRegistry>(), sp.GetRequiredService<PortTypeValidator>()))`
         - `services.AddScoped<IWiringEngine>(sp => new WiringEngine(sp.GetRequiredService<IEventBus>(), sp.GetRequiredService<IPortRegistry>(), sp.GetRequiredService<ILogger<WiringEngine>>()))`
       - Return `IServiceCollection` for chaining

    2. Update `src/OpenAnima.Core/Program.cs`:
       - Add `using OpenAnima.Core.DependencyInjection;`
       - Add `builder.Services.AddWiringServices();` after the LLM services section, before the hosted service registration
       - Single line, clean integration

    Do NOT register WiringInitializationService here — that comes in Plan 02.
  </action>
  <verify>
    <automated>cd /home/user/OpenAnima && dotnet build src/OpenAnima.Core/ --no-restore 2>&1 | tail -5 && dotnet test --no-build 2>&1 | tail -10</automated>
  </verify>
  <done>AddWiringServices() extension method exists, Program.cs calls it, project builds, all existing tests pass</done>
</task>

</tasks>

<verification>
1. `dotnet build src/OpenAnima.Core/` succeeds with no errors
2. `dotnet test` — all existing tests pass (no regressions)
3. IWiringEngine, IConfigurationLoader, IPortRegistry files exist with correct members
4. WiringServiceExtensions.cs exists with AddWiringServices() method
5. Program.cs contains `builder.Services.AddWiringServices()` call
</verification>

<success_criteria>
- Three interface files created with full public API surface
- Three concrete classes updated to implement interfaces
- Extension method registered all services with scoped lifetime
- Program.cs has single-line AddWiringServices() call
- All existing tests pass without modification (or with minimal constructor type updates)
</success_criteria>

<output>
After completion, create `.planning/phases/12.5-runtime-di-integration-tech-debt-fix/12.5-01-SUMMARY.md`
</output>
