# Phase 12.5: Runtime DI Integration & Tech Debt Fix - Research

**Researched:** 2026-02-26
**Domain:** .NET Dependency Injection, Blazor Server service lifetimes, runtime initialization patterns
**Confidence:** HIGH

## Summary

Phase 12.5 closes critical integration gaps identified in the v1.3 milestone audit. Three core services (WiringEngine, ConfigurationLoader, PortRegistry) exist and work in tests but are not registered in the DI container, making them unavailable at runtime. Additionally, port discovery results are ephemeral—discovered but never persisted to PortRegistry during module load.

The fix requires: (1) registering services in DI with appropriate lifetimes, (2) integrating port discovery into the module load flow, (3) providing configuration persistence with auto-load on startup. This unblocks Phase 13 (Visual Editor) and Phase 14 (Module Refactoring).

**Primary recommendation:** Use extension method pattern (`AddWiringServices()`) for clean DI registration, scoped lifetime for all three services to prepare for future multi-instance support, and integrate port registration into ModuleService.LoadModule() immediately after successful module registration.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- **Port Persistence Strategy:** In-memory storage with dynamic register/unregister support; ports registered immediately on module load (eager registration); ports automatically cleared when module is unloaded or stopped; if a module's port registration fails (type conflict, corrupt module), skip that module and log warning—don't block other modules; PortRegistry interface should support dynamic registration/unregistration to prepare for future dynamic module loading
- **Configuration Lifecycle:** Wiring configurations saved as JSON files; support multiple configuration files—users can save and switch between different wiring schemes; auto-load last used configuration on application startup; if configuration file is corrupt or incompatible, start with empty configuration + log warning; no backup/rollback mechanism needed for now
- **DI Registration Pattern:** Use extension methods (e.g., `AddWiringServices()`) to organize registration—one-line call in Program.cs; scoped lifetime for all core services (WiringEngine, PortRegistry, ConfigurationLoader)—prepares for future multi-Anima instances; register via interfaces (IWiringEngine, IPortRegistry, IConfigurationLoader), not concrete classes

### Claude's Discretion
- Internal implementation details of the extension method
- Exact JSON schema for configuration files (already defined in Phase 12)
- Error logging format and verbosity levels
- Initialization order of services during startup

### Deferred Ideas (OUT OF SCOPE)
- Module Marketplace—dynamic download and loading of modules at runtime (new capability, own phase)
- Multi-Anima instances—multiple Anima instances in same Dashboard with inter-instance messaging (new capability, own phase)
</user_constraints>

<phase_requirements>
## Phase Requirements

This phase unblocks the following requirements by fixing runtime integration gaps:

| ID | Description | Research Support |
|----|-------------|------------------|
| PORT-04 (runtime) | Modules declare ports via typed interface, discoverable at load time | Port discovery integration into ModuleService.LoadModule() flow; PortRegistry DI registration |
| WIRE-01 (runtime) | Runtime executes modules in topological order | WiringEngine DI registration; configuration auto-load on startup |
| WIRE-02 (runtime) | Circular dependency detection and rejection | WiringEngine DI registration; configuration validation on load |
| WIRE-03 (runtime) | Data routing between connected ports | WiringEngine DI registration; EventBus subscription setup |
| EDIT-03 | Drag-to-connect with bezier curve preview | PortRegistry population enables editor to query available ports |
| EDIT-05 | Save/load wiring configuration as JSON | ConfigurationLoader DI registration; file persistence patterns |
| EDIT-06 | Auto-save after changes | ConfigurationLoader DI registration; last-used config tracking |
| E2E-01 | ChatInput→LLM→ChatOutput working conversation | WiringEngine runtime execution; configuration load/execute flow |
</phase_requirements>

## Standard Stack

### Core (.NET 8.0 Built-ins)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Microsoft.Extensions.DependencyInjection | 8.0+ | Service registration and lifetime management | Built into .NET, industry standard for DI |
| Microsoft.Extensions.Hosting | 8.0+ | IHostedService for startup initialization | Standard pattern for background services and startup tasks |
| System.Text.Json | 8.0+ | Configuration file serialization | Already used in ConfigurationLoader, zero new dependencies |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Microsoft.Extensions.Logging | 8.0+ | Structured logging for DI operations | Already integrated, use for port registration and config load logging |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Scoped lifetime | Singleton | Singleton prevents future multi-instance support; user explicitly chose Scoped for future-proofing |
| Extension method | Direct registration in Program.cs | Extension method provides cleaner organization and encapsulation |
| IHostedService | Manual initialization in Program.cs | IHostedService provides proper lifecycle hooks and error handling |

**Installation:**
No new packages required—all dependencies already present in OpenAnima.Core.csproj.

## Architecture Patterns

### Recommended Project Structure
```
src/OpenAnima.Core/
├── DependencyInjection/
│   └── WiringServiceExtensions.cs    # AddWiringServices() extension method
├── Wiring/
│   ├── IWiringEngine.cs              # Interface for DI registration
│   ├── WiringEngine.cs               # Existing implementation
│   ├── IConfigurationLoader.cs       # Interface for DI registration
│   └── ConfigurationLoader.cs        # Existing implementation
├── Ports/
│   ├── IPortRegistry.cs              # Interface for DI registration
│   └── PortRegistry.cs               # Existing implementation
└── Hosting/
    └── WiringInitializationService.cs # IHostedService for config auto-load
```

### Pattern 1: Extension Method for Service Registration
**What:** Static extension method on IServiceCollection that encapsulates all wiring-related DI registrations
**When to use:** Organizing related service registrations into logical groups
**Example:**
```csharp
// Source: .NET DI guidelines + project conventions
public static class WiringServiceExtensions
{
    public static IServiceCollection AddWiringServices(
        this IServiceCollection services,
        string configDirectory)
    {
        // Register interfaces with scoped lifetime
        services.AddScoped<IPortRegistry, PortRegistry>();
        services.AddScoped<IWiringEngine, WiringEngine>();
        services.AddScoped<IConfigurationLoader>(sp =>
            new ConfigurationLoader(
                configDirectory,
                sp.GetRequiredService<IPortRegistry>(),
                sp.GetRequiredService<PortTypeValidator>()));

        // Register hosted service for initialization
        services.AddHostedService<WiringInitializationService>();

        return services;
    }
}
```

### Pattern 2: IHostedService for Startup Initialization
**What:** Background service that runs during application startup to perform one-time initialization
**When to use:** Loading configurations, populating registries, or performing startup validation
**Example:**
```csharp
// Source: Microsoft.Extensions.Hosting patterns
public class WiringInitializationService : IHostedService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<WiringInitializationService> _logger;

    public async Task StartAsync(CancellationToken ct)
    {
        // Create scope to resolve scoped services
        using var scope = _serviceProvider.CreateScope();
        var configLoader = scope.ServiceProvider
            .GetRequiredService<IConfigurationLoader>();

        // Auto-load last used configuration
        var lastConfig = GetLastUsedConfigName();
        if (lastConfig != null)
        {
            try
            {
                var config = await configLoader.LoadAsync(lastConfig, ct);
                var engine = scope.ServiceProvider
                    .GetRequiredService<IWiringEngine>();
                engine.LoadConfiguration(config);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex,
                    "Failed to auto-load configuration, starting empty");
            }
        }
    }
}
```

### Pattern 3: Port Registration Integration
**What:** Integrate PortDiscovery into ModuleService.LoadModule() flow immediately after successful module registration
**When to use:** Ensuring port metadata persists beyond discovery and is available for validation and editor queries
**Example:**
```csharp
// Source: Existing ModuleService pattern + PortDiscovery integration
public ModuleOperationResult LoadModule(string moduleDirectory)
{
    var result = _loader.LoadModule(moduleDirectory);

    if (result.Success && result.Module != null)
    {
        // Existing: Register module in PluginRegistry
        _pluginRegistry.Register(/*...*/);

        // NEW: Discover and register ports
        var moduleType = result.Module.GetType();
        var ports = _portDiscovery.DiscoverPorts(moduleType);

        try
        {
            _portRegistry.RegisterPorts(result.Manifest.Name, ports);
            _logger.LogInformation(
                "Registered {PortCount} ports for module {Name}",
                ports.Count, result.Manifest.Name);
        }
        catch (Exception ex)
        {
            // User decision: Skip module on port registration failure
            _logger.LogWarning(ex,
                "Port registration failed for {Name}, skipping module",
                result.Manifest.Name);
            return new ModuleOperationResult(
                result.Manifest.Name, false,
                $"Port registration failed: {ex.Message}");
        }
    }
}
```

### Pattern 4: Scoped Service Lifetime in Blazor Server
**What:** Services registered with AddScoped() have per-circuit lifetime in Blazor Server
**When to use:** Services that should be isolated per user connection but shared across components in that connection
**Blazor Server specifics:**
- Scoped = per SignalR circuit (one circuit per browser tab/connection)
- Singleton = shared across all users and circuits
- Transient = new instance per injection point

**Why Scoped for this phase:**
- User explicitly chose Scoped to prepare for future multi-Anima instances
- Each circuit could theoretically have its own wiring configuration
- Prevents accidental state sharing between users
- Aligns with Blazor Server best practices for stateful services

### Anti-Patterns to Avoid
- **Singleton for stateful services:** WiringEngine holds current configuration state—singleton would share state across all users
- **Constructor injection in IHostedService:** Scoped services cannot be injected into singleton IHostedService constructor—use IServiceProvider and CreateScope() instead
- **Ignoring port registration failures:** User decision requires logging warning and skipping module, not throwing exception that blocks other modules

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Service lifetime management | Manual singleton pattern with static fields | Microsoft.Extensions.DependencyInjection | Handles scoping, disposal, circular dependencies, and thread safety automatically |
| Startup initialization | Manual initialization in Program.cs | IHostedService | Provides proper lifecycle hooks, error handling, and cancellation token support |
| Configuration file tracking | Custom "last used" tracking system | Simple .lastconfig file or appsettings.json entry | Minimal, proven pattern; no need for complex state management |
| Service scope creation | Manual scope management | IServiceProvider.CreateScope() | Ensures proper disposal and prevents memory leaks |

**Key insight:** .NET's DI container handles complex lifetime management, disposal, and thread safety that would require hundreds of lines of custom code to replicate correctly.

## Common Pitfalls

### Pitfall 1: Injecting Scoped Services into Singleton IHostedService
**What goes wrong:** IHostedService is registered as singleton, but WiringEngine/ConfigurationLoader are scoped—direct constructor injection fails at runtime
**Why it happens:** Lifetime mismatch—singleton cannot depend on scoped service
**How to avoid:** Inject IServiceProvider, create scope in StartAsync(), resolve scoped services from scope
**Warning signs:** Runtime exception "Cannot consume scoped service from singleton"

### Pitfall 2: Forgetting to Dispose Service Scopes
**What goes wrong:** Memory leaks when scopes are created but not disposed
**Why it happens:** CreateScope() returns IServiceScope which implements IDisposable
**How to avoid:** Always use `using var scope = _serviceProvider.CreateScope();`
**Warning signs:** Memory usage grows over time, especially with repeated operations

### Pitfall 3: Port Registration Blocking Module Load
**What goes wrong:** One module's port registration failure prevents all subsequent modules from loading
**Why it happens:** Exception propagates up and stops the load loop
**User decision:** Skip failed module with warning, continue loading others
**How to avoid:** Wrap port registration in try-catch, log warning, return failure result for that module only
**Warning signs:** Module load stops after first port registration error

### Pitfall 4: Configuration Directory Not Created
**What goes wrong:** ConfigurationLoader.SaveAsync() fails because directory doesn't exist
**Why it happens:** Directory.CreateDirectory() only called in SaveAsync, not during DI registration
**How to avoid:** Create directory during service registration or in IHostedService.StartAsync()
**Warning signs:** First save operation fails with DirectoryNotFoundException

### Pitfall 5: Circular Dependency Between Services
**What goes wrong:** WiringEngine depends on PortRegistry, ConfigurationLoader depends on PortRegistry—if PortRegistry depends on either, circular dependency
**Why it happens:** Incorrect service dependencies
**How to avoid:** Keep dependency graph acyclic: PortRegistry → PortTypeValidator (no dependencies), ConfigurationLoader → PortRegistry + PortTypeValidator, WiringEngine → PortRegistry + EventBus
**Warning signs:** Runtime exception during service resolution

## Code Examples

Verified patterns from official sources and existing codebase:

### Extension Method Registration
```csharp
// Source: .NET DI guidelines + OpenAnima conventions
namespace OpenAnima.Core.DependencyInjection;

public static class WiringServiceExtensions
{
    public static IServiceCollection AddWiringServices(
        this IServiceCollection services,
        string? configDirectory = null)
    {
        // Default config directory if not specified
        configDirectory ??= Path.Combine(
            AppContext.BaseDirectory, "wiring-configs");

        // Ensure directory exists
        Directory.CreateDirectory(configDirectory);

        // Register core services with scoped lifetime
        services.AddScoped<IPortRegistry, PortRegistry>();
        services.AddScoped<IWiringEngine, WiringEngine>();

        // ConfigurationLoader needs constructor parameters
        services.AddScoped<IConfigurationLoader>(sp =>
            new ConfigurationLoader(
                configDirectory,
                sp.GetRequiredService<IPortRegistry>(),
                sp.GetRequiredService<PortTypeValidator>()));

        // Register initialization service
        services.AddHostedService<WiringInitializationService>();

        return services;
    }
}
```

### IHostedService for Auto-Load
```csharp
// Source: Microsoft.Extensions.Hosting patterns
public class WiringInitializationService : IHostedService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<WiringInitializationService> _logger;
    private readonly string _configDirectory;

    public WiringInitializationService(
        IServiceProvider serviceProvider,
        ILogger<WiringInitializationService> logger)
    {
        _serviceProvider = serviceProvider;
        _logger = logger;
        _configDirectory = Path.Combine(
            AppContext.BaseDirectory, "wiring-configs");
    }

    public async Task StartAsync(CancellationToken ct)
    {
        _logger.LogInformation("Initializing wiring system...");

        // Read last used config name
        var lastConfigPath = Path.Combine(_configDirectory, ".lastconfig");
        if (!File.Exists(lastConfigPath))
        {
            _logger.LogInformation(
                "No previous configuration found, starting empty");
            return;
        }

        var lastConfigName = await File.ReadAllTextAsync(lastConfigPath, ct);
        lastConfigName = lastConfigName.Trim();

        if (string.IsNullOrEmpty(lastConfigName))
        {
            _logger.LogInformation("Last config name is empty, starting empty");
            return;
        }

        // Create scope to resolve scoped services
        using var scope = _serviceProvider.CreateScope();
        var configLoader = scope.ServiceProvider
            .GetRequiredService<IConfigurationLoader>();
        var wiringEngine = scope.ServiceProvider
            .GetRequiredService<IWiringEngine>();

        try
        {
            _logger.LogInformation(
                "Auto-loading configuration: {ConfigName}", lastConfigName);
            var config = await configLoader.LoadAsync(lastConfigName, ct);
            wiringEngine.LoadConfiguration(config);
            _logger.LogInformation(
                "Configuration loaded successfully: {ConfigName}",
                config.Name);
        }
        catch (FileNotFoundException)
        {
            _logger.LogWarning(
                "Configuration file not found: {ConfigName}, starting empty",
                lastConfigName);
        }
        catch (InvalidOperationException ex)
        {
            _logger.LogWarning(ex,
                "Configuration validation failed: {ConfigName}, starting empty",
                lastConfigName);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex,
                "Failed to auto-load configuration: {ConfigName}, starting empty",
                lastConfigName);
        }
    }

    public Task StopAsync(CancellationToken ct)
    {
        _logger.LogInformation("Wiring system shutdown complete");
        return Task.CompletedTask;
    }
}
```

### Port Registration Integration
```csharp
// Source: Existing ModuleService pattern + integration point
// In ModuleService.LoadModule() after successful module registration:

// NEW: Discover and register ports
var moduleType = result.Module.GetType();
var ports = _portDiscovery.DiscoverPorts(moduleType);

try
{
    _portRegistry.RegisterPorts(result.Manifest.Name, ports);
    _logger.LogInformation(
        "Registered {PortCount} ports for module {ModuleName}",
        ports.Count, result.Manifest.Name);
}
catch (Exception ex)
{
    // User decision: Skip module on port registration failure
    _logger.LogWarning(ex,
        "Port registration failed for module {ModuleName}, skipping",
        result.Manifest.Name);

    // Unregister module from PluginRegistry since port registration failed
    _pluginRegistry.Unregister(result.Manifest.Name);

    return new ModuleOperationResult(
        result.Manifest.Name,
        false,
        $"Port registration failed: {ex.Message}");
}
```

### Last Config Tracking
```csharp
// Source: Simple file-based state pattern
// In ConfigurationLoader after successful save:

public async Task SaveAsync(WiringConfiguration config, CancellationToken ct = default)
{
    // Existing save logic...
    await using var stream = File.Create(filePath);
    await JsonSerializer.SerializeAsync(stream, config, JsonOptions, ct);

    // NEW: Track as last used configuration
    var lastConfigPath = Path.Combine(_configDirectory, ".lastconfig");
    await File.WriteAllTextAsync(lastConfigPath, config.Name, ct);
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual service instantiation in tests | DI container with interface-based registration | .NET Core 1.0 (2016) | Enables runtime injection, testability, and lifetime management |
| Singleton pattern for global state | Scoped services in Blazor Server | Blazor Server GA (2019) | Prevents state leakage between user circuits |
| Manual initialization in Program.cs | IHostedService for startup tasks | .NET Core 2.0 (2017) | Proper lifecycle hooks and error handling |
| XML configuration files | System.Text.Json for configuration | .NET Core 3.0 (2019) | Faster, built-in, no external dependencies |

**Deprecated/outdated:**
- Newtonsoft.Json for configuration: System.Text.Json is now standard and faster
- Static service locator pattern: DI container is the standard approach
- Transient lifetime for stateful services: Scoped is correct for per-circuit state in Blazor Server

## Open Questions

1. **Should PortRegistry be singleton instead of scoped?**
   - What we know: User chose scoped for future multi-instance support; port metadata is currently global (not per-circuit)
   - What's unclear: Whether port metadata should actually be per-circuit or global
   - Recommendation: Follow user decision (scoped) for now; if all circuits need same port metadata, can optimize to singleton in future without breaking changes

2. **Should configuration auto-load be optional?**
   - What we know: User wants auto-load on startup; corrupt configs should start empty with warning
   - What's unclear: Whether users might want to disable auto-load via appsettings.json
   - Recommendation: Implement auto-load as specified; add configuration option in future if users request it

3. **Should .lastconfig file be in wiring-configs directory or separate?**
   - What we know: Simple file-based tracking is sufficient
   - What's unclear: Best location for metadata file
   - Recommendation: Place in wiring-configs directory for simplicity; all wiring-related files in one place

## Validation Architecture

> Validation section included because workflow.nyquist_validation is not explicitly set to false in config.json

### Test Framework
| Property | Value |
|----------|-------|
| Framework | xUnit 2.9.3 |
| Config file | None—convention-based discovery |
| Quick run command | `dotnet test --filter "Category=Integration&FullyQualifiedName~Phase12_5" --no-build` |
| Full suite command | `dotnet test --no-build` |

### Phase Requirements → Test Map
| Req ID | Behavior | Test Type | Automated Command | File Exists? |
|--------|----------|-----------|-------------------|--------------|
| PORT-04 (runtime) | Ports registered during module load and persist in PortRegistry | integration | `dotnet test --filter "FullyQualifiedName~PortRegistrationIntegrationTests" --no-build` | ❌ Wave 0 |
| WIRE-01 (runtime) | WiringEngine injectable and executes modules in topological order | integration | `dotnet test --filter "FullyQualifiedName~WiringEngineRuntimeTests" --no-build` | ❌ Wave 0 |
| WIRE-02 (runtime) | Cycle detection works when WiringEngine injected from DI | integration | `dotnet test --filter "FullyQualifiedName~WiringEngineRuntimeTests" --no-build` | ❌ Wave 0 |
| WIRE-03 (runtime) | Data routing works when WiringEngine injected from DI | integration | `dotnet test --filter "FullyQualifiedName~WiringEngineRuntimeTests" --no-build` | ❌ Wave 0 |
| EDIT-03 | PortRegistry populated and queryable for editor | integration | `dotnet test --filter "FullyQualifiedName~PortRegistrationIntegrationTests" --no-build` | ❌ Wave 0 |
| EDIT-05 | ConfigurationLoader injectable and can save/load configurations | integration | `dotnet test --filter "FullyQualifiedName~ConfigurationLoaderRuntimeTests" --no-build` | ❌ Wave 0 |
| EDIT-06 | Last config tracking persists and auto-loads on startup | integration | `dotnet test --filter "FullyQualifiedName~WiringInitializationTests" --no-build` | ❌ Wave 0 |
| E2E-01 | Full flow: load config → execute → data routing works at runtime | integration | `dotnet test --filter "FullyQualifiedName~WiringEngineRuntimeTests" --no-build` | ❌ Wave 0 |

### Sampling Rate
- **Per task commit:** `dotnet test --filter "Category=Integration&FullyQualifiedName~Phase12_5" --no-build` (< 30 seconds)
- **Per wave merge:** `dotnet test --no-build` (full suite)
- **Phase gate:** Full suite green before `/gsd:verify-work`

### Wave 0 Gaps
- [ ] `tests/OpenAnima.Tests/Integration/PortRegistrationIntegrationTests.cs` — covers PORT-04, EDIT-03
- [ ] `tests/OpenAnima.Tests/Integration/WiringEngineRuntimeTests.cs` — covers WIRE-01, WIRE-02, WIRE-03, E2E-01
- [ ] `tests/OpenAnima.Tests/Integration/ConfigurationLoaderRuntimeTests.cs` — covers EDIT-05
- [ ] `tests/OpenAnima.Tests/Integration/WiringInitializationTests.cs` — covers EDIT-06
- [ ] Framework already installed and configured (xUnit 2.9.3)

## Sources

### Primary (HIGH confidence)
- .NET Dependency Injection Guidelines: https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection/guidelines (verified via WebSearch)
- ASP.NET Core Blazor DI: https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/dependency-injection (verified via WebSearch)
- Existing OpenAnima codebase: Program.cs, ModuleService.cs, OpenAnimaHostedService.cs (direct inspection)
- Phase 11 and 12 implementations: PortRegistry, WiringEngine, ConfigurationLoader (direct inspection)

### Secondary (MEDIUM confidence)
- [Service lifetimes in .NET](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection/service-lifetimes) - WebSearch verified
- [Blazor Basics: Dependency Injection Best Practices](https://www.telerik.com/blogs/blazor-basics-dependency-injection-best-practices-use-cases) - WebSearch verified
- [Background tasks with hosted services](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services) - WebSearch verified
- [Introducing IHostedLifecycleService in .NET 8](https://www.stevejgordon.co.uk/introducing-the-new-ihostedlifecycleservice-interface-in-dotnet-8) - WebSearch verified

### Tertiary (LOW confidence)
- None—all findings verified through official documentation or direct codebase inspection

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries are .NET built-ins, already present in project
- Architecture: HIGH - Patterns verified in existing codebase (OpenAnimaHostedService, ModuleService) and official .NET documentation
- Pitfalls: HIGH - Identified through codebase analysis and .NET DI best practices documentation

**Research date:** 2026-02-26
**Valid until:** 2026-03-26 (30 days—stable .NET patterns, unlikely to change)
