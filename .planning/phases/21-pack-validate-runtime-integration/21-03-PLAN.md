---
phase: 21-pack-validate-runtime-integration
plan: 03
type: execute
wave: 3
depends_on: [21-02]
files_modified:
  - src/OpenAnima.Core/Plugins/OamodExtractor.cs
  - src/OpenAnima.Core/Plugins/PluginLoader.cs
  - src/OpenAnima.Core/Plugins/ModuleDirectoryWatcher.cs
  - tests/OpenAnima.Cli.Tests/CliFoundationTests.cs
autonomous: true
requirements: [PACK-06]

must_haves:
  truths:
    - "Packed .oamod module loads in OpenAnima runtime without modification"
    - ".oamod files in modules/ directory are automatically extracted and loaded"
    - "Extracted modules load through existing PluginLoader.LoadModule() pathway"
  artifacts:
    - path: "src/OpenAnima.Core/Plugins/OamodExtractor.cs"
      provides: ".oamod ZIP extraction to loadable directory"
      contains: "class OamodExtractor"
    - path: "src/OpenAnima.Core/Plugins/PluginLoader.cs"
      provides: "Extended ScanDirectory to handle .oamod files"
      contains: "oamod"
    - path: "src/OpenAnima.Core/Plugins/ModuleDirectoryWatcher.cs"
      provides: "Extended watcher to detect .oamod files"
      contains: "oamod"
    - path: "tests/OpenAnima.Cli.Tests/CliFoundationTests.cs"
      provides: "Unit tests for OamodExtractor"
      contains: "OamodExtractor"
  key_links:
    - from: "src/OpenAnima.Core/Plugins/OamodExtractor.cs"
      to: "System.IO.Compression.ZipFile"
      via: "ZIP extraction"
      pattern: "ZipFile\\.ExtractToDirectory"
    - from: "src/OpenAnima.Core/Plugins/PluginLoader.cs"
      to: "src/OpenAnima.Core/Plugins/OamodExtractor.cs"
      via: "Extract .oamod before loading"
      pattern: "OamodExtractor\\.Extract"
    - from: "src/OpenAnima.Core/Plugins/ModuleDirectoryWatcher.cs"
      to: "src/OpenAnima.Core/Plugins/OamodExtractor.cs"
      via: "Extract .oamod on hot reload"
      pattern: "OamodExtractor|oamod"
---

<objective>
Extend the OpenAnima runtime to load packed .oamod modules seamlessly.

Purpose: The packed .oamod files produced by `oani pack` must be loadable by the runtime without any manual extraction. This completes the full develop-validate-pack-load cycle (PACK-06).

Output: OamodExtractor.cs, extended PluginLoader and ModuleDirectoryWatcher, with unit tests.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-pack-validate-runtime-integration/21-RESEARCH.md
@.planning/phases/21-pack-validate-runtime-integration/21-02-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/OpenAnima.Core/Plugins/PluginLoader.cs:
```csharp
public class PluginLoader
{
    public record LoadResult(IModule? Module, PluginLoadContext? Context, PluginManifest? Manifest, Exception? Error, bool Success);
    public LoadResult LoadModule(string moduleDirectory);
    public IReadOnlyList<LoadResult> ScanDirectory(string modulesPath);
}
```

From src/OpenAnima.Core/Plugins/PluginManifest.cs:
```csharp
public class PluginManifest
{
    [JsonPropertyName("name")] public string Name { get; set; } = string.Empty;
    [JsonPropertyName("version")] public string Version { get; set; } = string.Empty;
    [JsonPropertyName("description")] public string? Description { get; set; }
    [JsonPropertyName("entryAssembly")] public string EntryAssembly { get; set; } = string.Empty;
    public static PluginManifest LoadFromDirectory(string moduleDirectory);
}
```

From src/OpenAnima.Core/Plugins/ModuleDirectoryWatcher.cs:
```csharp
public class ModuleDirectoryWatcher : IDisposable
{
    // Currently watches NotifyFilters.DirectoryName only
    // _watcher.Created += OnDirectoryCreated;
    // Debounce: 500ms timer before invoking callback
    public ModuleDirectoryWatcher(string modulesPath, Action<string> onModuleDiscovered);
    public void StartWatching();
    public void RefreshAll();
}
```

From src/OpenAnima.Core/Hosting/OpenAnimaHostedService.cs:
```csharp
// StartAsync flow:
// 1. modulesPath = Path.Combine(AppContext.BaseDirectory, "modules")
// 2. _moduleService.ScanAndLoadAll(modulesPath)
// 3. _watcher = new ModuleDirectoryWatcher(modulesPath, path => { _moduleService.LoadModule(path); })
// 4. _watcher.StartWatching()
```

From src/OpenAnima.Core/Services/IModuleService.cs:
```csharp
public interface IModuleService
{
    ModuleOperationResult LoadModule(string moduleDirectory);
    IReadOnlyList<ModuleOperationResult> ScanAndLoadAll(string modulesPath);
}
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Create OamodExtractor and extend PluginLoader.ScanDirectory</name>
  <files>src/OpenAnima.Core/Plugins/OamodExtractor.cs, src/OpenAnima.Core/Plugins/PluginLoader.cs, tests/OpenAnima.Cli.Tests/CliFoundationTests.cs</files>
  <behavior>
    - Test: OamodExtractor.Extract extracts a .oamod ZIP to the specified base directory
    - Test: Extracted directory contains module.json and the DLL file
    - Test: OamodExtractor.Extract with already-extracted directory overwrites cleanly (idempotent)
    - Test: PluginLoader.ScanDirectory picks up .oamod files in addition to subdirectories
  </behavior>
  <action>
1. **Create `src/OpenAnima.Core/Plugins/OamodExtractor.cs`**:

   ```csharp
   using System.IO.Compression;

   namespace OpenAnima.Core.Plugins;

   /// <summary>
   /// Extracts .oamod packages (ZIP files) to loadable directories.
   /// </summary>
   public static class OamodExtractor
   {
       /// <summary>
       /// Extracts a .oamod file to a subdirectory of extractBasePath.
       /// Returns the path to the extracted directory (ready for PluginLoader.LoadModule).
       /// </summary>
       public static string Extract(string oamodPath, string extractBasePath)
   }
   ```

   Implementation:
   - Derive module name from filename: `Path.GetFileNameWithoutExtension(oamodPath)`.
   - Extract directory: `Path.Combine(extractBasePath, ".extracted", moduleName)`.
   - Create `.extracted/` subdirectory if it doesn't exist.
   - If the extract directory already exists, delete it recursively (clean re-extract for idempotency).
   - Call `ZipFile.ExtractToDirectory(oamodPath, extractDir)`.
   - Return `extractDir`.

   **Design choice (Claude's discretion):** Keep `module.json` as the filename inside the .oamod (simpler than the manifest.json rename approach in research). This means the extracted directory is immediately compatible with `PluginLoader.LoadModule()` with no rename step needed.

   **Anti-pattern to avoid:** Do NOT extract on every startup if already extracted. Add a `NeedsExtraction` check:
   ```csharp
   public static bool NeedsExtraction(string oamodPath, string extractBasePath)
   ```
   Compare the .oamod file's `LastWriteTimeUtc` with a timestamp marker file in the extracted directory. If .oamod is newer or marker doesn't exist, re-extract.

2. **Extend `src/OpenAnima.Core/Plugins/PluginLoader.cs`** `ScanDirectory` method:
   After the existing `foreach (string subdirectory in Directory.GetDirectories(modulesPath))` loop, add a second loop:
   ```csharp
   // Also scan for .oamod packages
   foreach (string oamodFile in Directory.GetFiles(modulesPath, "*.oamod"))
   {
       try
       {
           var extractedDir = OamodExtractor.Extract(oamodFile, modulesPath);
           results.Add(LoadModule(extractedDir));
       }
       catch (Exception ex)
       {
           results.Add(new LoadResult(null, null, null, ex, false));
       }
   }
   ```

   **CRITICAL:** The `.extracted/` subdirectory must be skipped by the directory scan loop to avoid double-loading. Add a check: skip subdirectories named `.extracted`. Update the directory loop:
   ```csharp
   foreach (string subdirectory in Directory.GetDirectories(modulesPath))
   {
       if (Path.GetFileName(subdirectory) == ".extracted")
           continue;
       results.Add(LoadModule(subdirectory));
   }
   ```

3. **Add unit tests** in `tests/OpenAnima.Cli.Tests/CliFoundationTests.cs`:

   New test class `OamodExtractorTests`:
   - Need a `[assembly: InternalsVisibleTo("OpenAnima.Cli.Tests")]` or make classes public (they already are).
   - Actually, OamodExtractor is in OpenAnima.Core, and the test project references OpenAnima.Cli. Add a project reference to OpenAnima.Core in the test csproj if not already present, OR create a minimal test that creates a ZIP with module.json + a dummy .dll file, calls `OamodExtractor.Extract`, and verifies the extracted contents.
   - Test: Create temp .oamod (ZIP with module.json and dummy.dll), extract it, verify both files exist in extracted directory.
   - Test: Re-extract (idempotency) -- call Extract twice, verify no errors and files are correct.
   - Test: NeedsExtraction returns true when no extraction exists, false after extraction with same timestamp.
  </action>
  <verify>
    <automated>cd /home/user/OpenAnima && dotnet test tests/OpenAnima.Cli.Tests/ --filter "OamodExtractor" --no-restore --verbosity normal 2>&1 | tail -20</automated>
  </verify>
  <done>
    - OamodExtractor.cs exists with Extract and NeedsExtraction methods
    - PluginLoader.ScanDirectory handles .oamod files alongside directories
    - .extracted/ subdirectory is skipped during directory scan (no double-load)
    - Extraction is idempotent and timestamp-aware
    - All OamodExtractor tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend OpenAnimaHostedService for .oamod hot reload and verify E2E</name>
  <files>src/OpenAnima.Core/Hosting/OpenAnimaHostedService.cs, src/OpenAnima.Core/Plugins/ModuleDirectoryWatcher.cs, tests/OpenAnima.Cli.Tests/CliFoundationTests.cs</files>
  <action>
1. **Extend `src/OpenAnima.Core/Plugins/ModuleDirectoryWatcher.cs`** to watch for .oamod files:

   In `StartWatching()`, after the existing directory watcher setup, add a second `FileSystemWatcher` for .oamod files:
   ```csharp
   // Watch for .oamod file additions
   _fileWatcher = new FileSystemWatcher(_modulesPath)
   {
       NotifyFilter = NotifyFilters.FileName | NotifyFilters.LastWrite,
       Filter = "*.oamod",
       IncludeSubdirectories = false
   };
   _fileWatcher.Created += OnOamodCreated;
   _fileWatcher.Changed += OnOamodCreated; // Handle overwrites too
   _fileWatcher.EnableRaisingEvents = true;
   ```

   Add a private `FileSystemWatcher? _fileWatcher` field.

   Add `OnOamodCreated` handler that uses the same debounce pattern (500ms) as `OnDirectoryCreated`:
   - On debounce completion, call `OamodExtractor.Extract(oamodPath, _modulesPath)` to extract.
   - Then invoke `_onModuleDiscovered(extractedDir)` with the extracted directory path.
   - Wrap in try/catch -- log but don't crash on extraction failure (file might still be copying).

   In `StopWatching()` and `Dispose()`, also dispose `_fileWatcher`.

   In `RefreshAll()`, also scan for `*.oamod` files and extract+discover any new ones.

2. **Verify `OpenAnimaHostedService.cs`** needs NO changes:
   The hosted service already uses `_moduleService.ScanAndLoadAll(modulesPath)` which calls `PluginLoader.ScanDirectory()` (now extended to handle .oamod). The watcher callback already calls `_moduleService.LoadModule(path)` which works with extracted directories. The key change is in `ModuleDirectoryWatcher` (which detects .oamod) and `PluginLoader.ScanDirectory()` (which extracts them). If OpenAnimaHostedService DOES need changes (e.g., the watcher callback needs to handle .oamod extraction before calling LoadModule), make the minimal necessary change.

   **Most likely:** OpenAnimaHostedService needs no changes because:
   - Initial scan: `ScanAndLoadAll` -> `PluginLoader.ScanDirectory` (already extended)
   - Hot reload: `ModuleDirectoryWatcher` now detects .oamod files and extracts before calling `_onModuleDiscovered(extractedDir)`

3. **Add integration tests** for the full flow:
   - Test: Create a fake .oamod file (ZIP with valid module.json + dummy DLL) in a temp modules directory. Call `PluginLoader.ScanDirectory(tempModulesPath)`. Verify the .oamod was extracted to `.extracted/` subdirectory. (The LoadModule will fail since the DLL is fake, but extraction should succeed.)
   - Test: Verify that `.extracted/` directory is skipped by directory scan (create both a .oamod and a regular module directory, ensure no double-loading of the extracted module).

4. Run full test suite to verify no regressions across all existing and new tests.

5. Build the entire solution (`dotnet build`) to verify Core + CLI both compile cleanly.
  </action>
  <verify>
    <automated>cd /home/user/OpenAnima && dotnet build src/OpenAnima.Core/ --no-restore --verbosity normal 2>&1 | tail -10 && dotnet test tests/OpenAnima.Cli.Tests/ --no-restore --verbosity normal 2>&1 | tail -20</automated>
  </verify>
  <done>
    - ModuleDirectoryWatcher watches for .oamod files in addition to directories
    - Hot reload works for .oamod files (extract + load on file creation)
    - .extracted/ directory is properly managed (skipped by directory scan)
    - Full solution builds without errors
    - All tests pass (validate + pack + extractor + existing)
    - PACK-06 satisfied: packed module loads in runtime without modification
  </done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds for both OpenAnima.Core and OpenAnima.Cli projects
- `dotnet test tests/OpenAnima.Cli.Tests/` shows all tests passing
- OamodExtractor correctly extracts .oamod ZIP files to .extracted/ subdirectory
- PluginLoader.ScanDirectory detects and extracts .oamod files
- ModuleDirectoryWatcher detects new .oamod files and triggers extraction + loading
- No double-loading occurs (`.extracted/` directory skipped during scan)
</verification>

<success_criteria>
1. OamodExtractor.cs extracts .oamod ZIPs to loadable directories
2. PluginLoader.ScanDirectory handles both directories and .oamod files
3. ModuleDirectoryWatcher detects .oamod file additions for hot reload
4. Extracted modules load through existing PluginLoader.LoadModule() pathway
5. .extracted/ subdirectory managed correctly (no double-load, clean re-extract)
6. Full solution builds and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/21-pack-validate-runtime-integration/21-03-SUMMARY.md`
</output>
