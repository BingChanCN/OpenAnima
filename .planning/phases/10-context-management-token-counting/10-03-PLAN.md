---
phase: 10-context-management-token-counting
plan: 03
type: execute
wave: 1
depends_on: ["10-01", "10-02"]
files_modified:
  - src/OpenAnima.Core/Services/ChatContextManager.cs
  - src/OpenAnima.Core/Components/Shared/ChatPanel.razor
autonomous: true
requirements: [CTX-02]
gap_closure: true

must_haves:
  truths:
    - "Oldest user/assistant message pairs are automatically removed when context exceeds 80% before sending"
    - "System message (index 0) is never removed during truncation"
    - "User can have 20+ message conversations without hitting context limit errors"
    - "Truncation event is published to EventBus with removed message count and freed tokens"
  artifacts:
    - path: "src/OpenAnima.Core/Services/ChatContextManager.cs"
      provides: "TruncateOldestMessages method that removes oldest user/assistant pairs preserving system message"
      contains: "TruncateOldestMessages"
    - path: "src/OpenAnima.Core/Components/Shared/ChatPanel.razor"
      provides: "Automatic truncation call before sending when context > 80%"
  key_links:
    - from: "src/OpenAnima.Core/Components/Shared/ChatPanel.razor"
      to: "src/OpenAnima.Core/Services/ChatContextManager.cs"
      via: "TruncateOldestMessages call before CanSendMessage check"
      pattern: "TruncateOldestMessages"
    - from: "src/OpenAnima.Core/Services/ChatContextManager.cs"
      to: "src/OpenAnima.Core/Events/ChatEvents.cs"
      via: "ContextLimitReachedPayload published on truncation"
      pattern: "ContextLimitReachedPayload"
---

<objective>
Implement automatic message truncation to close the CTX-02 gap: when context usage exceeds 80%, oldest user/assistant message pairs are removed (preserving system message) so conversations can continue beyond 20+ messages without hitting the hard 90% send-block.

Purpose: The current system only blocks sends at 90% — users hit a dead end. Truncation enables seamless long conversations by freeing context space automatically.
Output: Updated ChatContextManager.cs with TruncateOldestMessages(), updated ChatPanel.razor with pre-send truncation logic.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-context-management-token-counting/10-VERIFICATION.md
@.planning/phases/10-context-management-token-counting/10-01-SUMMARY.md
@.planning/phases/10-context-management-token-counting/10-02-SUMMARY.md
@src/OpenAnima.Core/Services/ChatContextManager.cs
@src/OpenAnima.Core/Components/Shared/ChatPanel.razor
@src/OpenAnima.Core/LLM/TokenCounter.cs
@src/OpenAnima.Core/Events/ChatEvents.cs
@src/OpenAnima.Core/LLM/ILLMService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TruncateOldestMessages method to ChatContextManager</name>
  <files>src/OpenAnima.Core/Services/ChatContextManager.cs</files>
  <action>
Add a `TruncateOldestMessages` method to ChatContextManager that removes oldest user/assistant message pairs from a conversation history list when context exceeds 80% of MaxContextTokens.

Method signature:
```csharp
public int TruncateOldestMessages(List<ChatMessageInput> messages, double truncationThreshold = 0.8)
```

Implementation:
1. Calculate current token count of all messages using `_tokenCounter.CountMessages(messages)`
2. Calculate target: `MaxContextTokens * truncationThreshold`
3. If current tokens <= target, return 0 (no truncation needed)
4. Identify system message: if `messages[0].Role == "system"`, preserve it (start removing from index 1)
5. Remove messages from the start (after system message) in pairs (user + assistant) until token count drops below target:
   - Find the first non-system message (index 1 if system exists, index 0 otherwise)
   - Remove it, increment removed count
   - Recount tokens after each removal using `_tokenCounter.CountMessages(messages)`
   - Continue until under target or only system message remains
6. Log the truncation: `_logger.LogInformation("Truncated {Count} messages, freed {Freed} tokens", removedCount, freedTokens)`
7. Update `CurrentContextTokens` to the new token count after truncation
8. Fire `OnStateChanged` event
9. Return the number of messages removed

Important:
- The method mutates the passed `List<ChatMessageInput>` directly (caller's list)
- Track freed tokens as `originalTokens - newTokens` for logging and event publishing
- Use lock for thread safety consistent with existing pattern
- Do NOT publish EventBus events from this method — the caller (ChatPanel) handles event publishing to keep the service layer decoupled from async EventBus calls
  </action>
  <verify>
    <automated>cd /home/user/OpenAnima && dotnet build src/OpenAnima.Core 2>&1 | tail -5</automated>
    <manual>Verify ChatContextManager.cs contains TruncateOldestMessages method with system message preservation logic</manual>
  </verify>
  <done>ChatContextManager has TruncateOldestMessages method that removes oldest messages while preserving system message, updates CurrentContextTokens, and returns removed count. Build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Wire automatic truncation into ChatPanel before sending</name>
  <files>src/OpenAnima.Core/Components/Shared/ChatPanel.razor</files>
  <action>
Update ChatPanel.razor's `SendMessage` method to call truncation before the CanSendMessage check, enabling long conversations to continue automatically.

In `SendMessage`, BEFORE the existing `CanSendMessage` check (around line 72), add truncation logic:

1. Build the history list as `List<ChatMessageInput>` (not just IReadOnlyList) — it needs to be mutable for truncation:
   ```csharp
   var history = _messages
       .Where(m => !m.IsStreaming)
       .Select(m => new ChatMessageInput(m.Role, m.Content))
       .ToList();
   ```

2. Call truncation BEFORE CanSendMessage:
   ```csharp
   var removedCount = _contextManager.TruncateOldestMessages(history);
   ```

3. If messages were removed (`removedCount > 0`):
   - Sync the UI `_messages` list to match: remove the same number of oldest non-system messages from `_messages` (skip index 0 if it's a system message)
   - Publish a ContextLimitReachedPayload event to EventBus with current token state (reuse existing event pattern from line 79-84)
   - Call `StateHasChanged` so the UI reflects removed messages

4. Then proceed with existing `CanSendMessage` check using the (now potentially truncated) history

5. Also apply the same truncation logic in `RegenerateLastResponse` before streaming — build mutable history, truncate, sync UI messages if needed.

Key details:
- The `_messages` list uses `ChatMessageModel` (Role, Content, IsStreaming) while truncation works on `ChatMessageInput` (Role, Content). Sync by removing from the front of `_messages` (after any system message) to match what was truncated from `history`.
- System messages in `_messages` are identified by `Role == "system"` at index 0.
- After truncation sync, the `_messages` list and `history` list should have the same non-streaming messages.
  </action>
  <verify>
    <automated>cd /home/user/OpenAnima && dotnet build src/OpenAnima.Core 2>&1 | tail -5</automated>
    <manual>Run the app, set MaxContextTokens to a small value (e.g., 1000) in appsettings.json, send messages until context approaches 80%, verify oldest messages disappear from chat and conversation continues</manual>
  </verify>
  <done>ChatPanel automatically truncates oldest messages when context > 80% before sending, UI reflects removed messages, conversation can continue past 20+ messages, ContextLimitReached event published on truncation, build passes</done>
</task>

</tasks>

<verification>
1. `dotnet build src/OpenAnima.Core` — zero errors
2. ChatContextManager.cs contains `TruncateOldestMessages` method
3. Method preserves system message (index 0 with role "system")
4. Method removes messages from oldest first, recounts tokens after each removal
5. ChatPanel.razor calls TruncateOldestMessages before CanSendMessage in SendMessage
6. ChatPanel.razor syncs UI _messages list after truncation
7. ContextLimitReachedPayload event published when truncation occurs
8. Truncation also applied in RegenerateLastResponse path
</verification>

<success_criteria>
- Build passes with zero errors
- TruncateOldestMessages removes oldest messages while preserving system message
- ChatPanel calls truncation automatically when context > 80% before sending
- UI reflects removed messages (they disappear from chat)
- Conversations can continue past 20+ messages via automatic truncation
- EventBus event published when truncation occurs
</success_criteria>

<output>
After completion, create `.planning/phases/10-context-management-token-counting/10-03-SUMMARY.md`
</output>
