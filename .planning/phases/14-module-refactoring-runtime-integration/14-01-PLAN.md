---
phase: 14-module-refactoring-runtime-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/OpenAnima.Contracts/IModuleExecutor.cs
  - src/OpenAnima.Contracts/ModuleExecutionState.cs
  - src/OpenAnima.Core/Modules/LLMModule.cs
  - src/OpenAnima.Core/Modules/ChatInputModule.cs
  - src/OpenAnima.Core/Modules/ChatOutputModule.cs
  - src/OpenAnima.Core/Modules/HeartbeatModule.cs
  - tests/OpenAnima.Tests/Modules/ModuleTests.cs
autonomous: true
requirements: [RMOD-01, RMOD-02, RMOD-03, RMOD-04]

must_haves:
  truths:
    - "LLMModule accepts text on input port and produces LLM response on output port"
    - "ChatInputModule captures user text and publishes to output port"
    - "ChatOutputModule receives text on input port and makes it available for display"
    - "HeartbeatModule fires trigger events at configured interval via output port"
    - "All modules implement IModuleExecutor with state tracking (Idle/Running/Completed/Error)"
  artifacts:
    - path: "src/OpenAnima.Contracts/IModuleExecutor.cs"
      provides: "SDK interface extending IModule with ExecuteAsync and GetState"
      exports: ["IModuleExecutor"]
    - path: "src/OpenAnima.Contracts/ModuleExecutionState.cs"
      provides: "Execution state enum"
      exports: ["ModuleExecutionState"]
    - path: "src/OpenAnima.Core/Modules/LLMModule.cs"
      provides: "LLM module with prompt input and response output ports"
      contains: "class LLMModule : IModuleExecutor"
    - path: "src/OpenAnima.Core/Modules/ChatInputModule.cs"
      provides: "Chat input module with text output port"
      contains: "class ChatInputModule : IModuleExecutor"
    - path: "src/OpenAnima.Core/Modules/ChatOutputModule.cs"
      provides: "Chat output module with text input port"
      contains: "class ChatOutputModule : IModuleExecutor"
    - path: "src/OpenAnima.Core/Modules/HeartbeatModule.cs"
      provides: "Heartbeat module with trigger output port"
      contains: "class HeartbeatModule : IModuleExecutor"
  key_links:
    - from: "src/OpenAnima.Core/Modules/LLMModule.cs"
      to: "IEventBus"
      via: "Subscribe to input port, publish to output port"
      pattern: "_eventBus\\.Subscribe.*\\.port\\."
    - from: "src/OpenAnima.Core/Modules/ChatInputModule.cs"
      to: "IEventBus"
      via: "Publish user text to output port"
      pattern: "_eventBus\\.PublishAsync.*\\.port\\."
    - from: "src/OpenAnima.Core/Modules/HeartbeatModule.cs"
      to: "IEventBus"
      via: "Publish trigger on tick"
      pattern: "_eventBus\\.PublishAsync.*\\.port\\.tick"
---

<objective>
Define the Module SDK interface (IModuleExecutor) and implement all four concrete modules: LLMModule, ChatInputModule, ChatOutputModule, HeartbeatModule.

Purpose: Transform hardcoded services into port-based modules that communicate exclusively through EventBus ports, establishing the foundation for wiring-driven execution.
Output: SDK contracts in OpenAnima.Contracts + 4 module implementations in OpenAnima.Core/Modules + unit tests
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-module-refactoring-runtime-integration/14-CONTEXT.md
@.planning/phases/14-module-refactoring-runtime-integration/14-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/OpenAnima.Contracts/IModule.cs:
```csharp
public interface IModule
{
    IModuleMetadata Metadata { get; }
    Task InitializeAsync(CancellationToken cancellationToken = default);
    Task ShutdownAsync(CancellationToken cancellationToken = default);
}
```

From src/OpenAnima.Contracts/IEventBus.cs:
```csharp
public interface IEventBus
{
    Task PublishAsync<TPayload>(ModuleEvent<TPayload> evt, CancellationToken ct = default);
    Task<TResponse> SendAsync<TResponse>(string targetModuleId, object request, CancellationToken ct = default);
    IDisposable Subscribe<TPayload>(string eventName, Func<ModuleEvent<TPayload>, CancellationToken, Task> handler, Func<ModuleEvent<TPayload>, bool>? filter = null);
}
```

From src/OpenAnima.Contracts/ModuleEvent.cs:
```csharp
public class ModuleEvent<TPayload> : ModuleEvent
{
    public TPayload Payload { get; set; } = default!;
}
```

From src/OpenAnima.Contracts/Ports/InputPortAttribute.cs + OutputPortAttribute.cs:
```csharp
[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public class InputPortAttribute : Attribute { public string Name { get; } public PortType Type { get; } }
[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public class OutputPortAttribute : Attribute { public string Name { get; } public PortType Type { get; } }
```

From src/OpenAnima.Contracts/ITickable.cs:
```csharp
public interface ITickable { Task TickAsync(CancellationToken ct = default); }
```

From src/OpenAnima.Core/LLM/ILLMService.cs:
```csharp
public interface ILLMService
{
    Task<LLMResult> CompleteAsync(IReadOnlyList<ChatMessageInput> messages, CancellationToken ct = default);
    IAsyncEnumerable<string> StreamAsync(IReadOnlyList<ChatMessageInput> messages, CancellationToken ct = default);
}
```

From src/OpenAnima.Contracts/Ports/PortType.cs:
```csharp
public enum PortType { Text = 0, Trigger = 1 }
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Module SDK contracts (IModuleExecutor + ModuleExecutionState)</name>
  <files>
    src/OpenAnima.Contracts/IModuleExecutor.cs
    src/OpenAnima.Contracts/ModuleExecutionState.cs
  </files>
  <action>
Create two files in OpenAnima.Contracts:

1. `ModuleExecutionState.cs` — enum with values: Idle, Running, Completed, Error

2. `IModuleExecutor.cs` — interface extending IModule:
   - `Task ExecuteAsync(CancellationToken ct = default)` — called by WiringEngine when module should execute. Module reads from input ports (via EventBus subscriptions set up in InitializeAsync) and writes to output ports (via EventBus publish).
   - `ModuleExecutionState GetState()` — returns current execution state for monitoring.
   - `Exception? GetLastError()` — returns last error for error detail display in editor.

Per user decision: SDK interface defined first, modules implemented after. This is the foundation contract.
Per user decision: Modules are fully isolated — IModuleExecutor does NOT expose any DI-shared services. All data exchange through ports and events only.
  </action>
  <verify>
    <automated>cd /home/user/OpenAnima && dotnet build src/OpenAnima.Contracts/OpenAnima.Contracts.csproj --no-restore 2>&1 | tail -5</automated>
  </verify>
  <done>IModuleExecutor interface exists extending IModule with ExecuteAsync, GetState, GetLastError. ModuleExecutionState enum exists with Idle/Running/Completed/Error values. Contracts project builds.</done>
</task>

<task type="auto">
  <name>Task 2: Implement concrete modules (LLM, ChatInput, ChatOutput, Heartbeat)</name>
  <files>
    src/OpenAnima.Core/Modules/LLMModule.cs
    src/OpenAnima.Core/Modules/ChatInputModule.cs
    src/OpenAnima.Core/Modules/ChatOutputModule.cs
    src/OpenAnima.Core/Modules/HeartbeatModule.cs
    tests/OpenAnima.Tests/Modules/ModuleTests.cs
  </files>
  <action>
Create `src/OpenAnima.Core/Modules/` directory with 4 module implementations. All implement IModuleExecutor.

**LLMModule** (RMOD-01):
- Attributes: `[InputPort("prompt", PortType.Text)]`, `[OutputPort("response", PortType.Text)]`
- Constructor: `(ILLMService llmService, IEventBus eventBus, ILogger<LLMModule> logger)`
- Metadata: Name="LLMModule", Version="1.0.0", Description="Sends prompt to LLM and outputs response"
- InitializeAsync: Subscribe to `{Metadata.Name}.port.prompt` event. On receive, store prompt and call ExecuteAsync.
- ExecuteAsync: Set state=Running. Call `_llmService.CompleteAsync(messages, ct)`. On success, publish result to `{Metadata.Name}.port.response`. Set state=Completed. On error, set state=Error, store exception, rethrow.
- ShutdownAsync: Dispose all subscriptions.
- Store subscriptions in `List<IDisposable>`, dispose all in ShutdownAsync (per research pitfall #2).

**ChatInputModule** (RMOD-02):
- Attributes: `[OutputPort("userMessage", PortType.Text)]`
- Constructor: `(IEventBus eventBus, ILogger<ChatInputModule> logger)`
- Metadata: Name="ChatInputModule", Version="1.0.0"
- Provides `SendMessageAsync(string message)` public method that publishes to `{Metadata.Name}.port.userMessage`. This is called by the chat UI when user sends a message.
- ExecuteAsync: No-op (input module is event-driven from UI, not from wiring execution).
- No input ports — this is a source module.

**ChatOutputModule** (RMOD-03):
- Attributes: `[InputPort("displayText", PortType.Text)]`
- Constructor: `(IEventBus eventBus, ILogger<ChatOutputModule> logger)`
- Metadata: Name="ChatOutputModule", Version="1.0.0"
- InitializeAsync: Subscribe to `{Metadata.Name}.port.displayText`. On receive, store text and fire `OnMessageReceived` event (Action<string>).
- Provides `event Action<string>? OnMessageReceived` for UI binding.
- Provides `string? LastReceivedText` property.
- No output ports — this is a sink module.

**HeartbeatModule** (RMOD-04):
- Attributes: `[OutputPort("tick", PortType.Trigger)]`
- Implements both IModuleExecutor and ITickable
- Constructor: `(IEventBus eventBus, ILogger<HeartbeatModule> logger)`
- Metadata: Name="HeartbeatModule", Version="1.0.0"
- TickAsync: Publish trigger event to `{Metadata.Name}.port.tick` with `{ Timestamp = DateTime.UtcNow }` payload.
- ExecuteAsync: No-op (heartbeat is tick-driven, not wiring-driven).
- No input ports — this is a source/timer module.

**Unit tests** in `tests/OpenAnima.Tests/Modules/ModuleTests.cs`:
- Test LLMModule: verify state transitions (Idle→Running→Completed), verify output port publish on successful execution.
- Test ChatInputModule: verify SendMessageAsync publishes to correct event name.
- Test ChatOutputModule: verify OnMessageReceived fires when input port receives data.
- Test HeartbeatModule: verify TickAsync publishes trigger event.
- Use real EventBus (not mocks) per project pattern — fresh EventBus per test method.
- Use TaskCompletionSource with 5-second timeout for event verification (per Phase 11 pattern).
  </action>
  <verify>
    <automated>cd /home/user/OpenAnima && dotnet test tests/OpenAnima.Tests/ --filter "FullyQualifiedName~ModuleTests" --no-restore -v minimal 2>&1 | tail -10</automated>
  </verify>
  <done>All 4 modules implement IModuleExecutor with correct port attributes. LLMModule subscribes to prompt input and publishes response output. ChatInputModule publishes user messages. ChatOutputModule receives and exposes display text. HeartbeatModule publishes trigger on tick. All module tests pass.</done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds for both OpenAnima.Contracts and OpenAnima.Core
- `dotnet test --filter "ModuleTests"` — all module unit tests pass
- Each module class has correct InputPort/OutputPort attributes
- Each module implements IModuleExecutor (InitializeAsync, ExecuteAsync, ShutdownAsync, GetState, GetLastError)
</verification>

<success_criteria>
- IModuleExecutor SDK interface defined in Contracts project
- 4 concrete modules in Core/Modules/ with port-based communication via EventBus
- All modules fully isolated — no direct module-to-module references, no DI-shared services between modules
- Unit tests verify port publish/subscribe behavior for each module
</success_criteria>

<output>
After completion, create `.planning/phases/14-module-refactoring-runtime-integration/14-01-SUMMARY.md`
</output>
