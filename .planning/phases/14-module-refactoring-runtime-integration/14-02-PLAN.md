---
phase: 14-module-refactoring-runtime-integration
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/OpenAnima.Core/Hubs/IRuntimeClient.cs
  - src/OpenAnima.Core/Wiring/WiringEngine.cs
  - src/OpenAnima.Core/Services/EditorStateService.cs
  - src/OpenAnima.Core/Components/Shared/NodeCard.razor
  - src/OpenAnima.Core/Components/Shared/EditorCanvas.razor
autonomous: true
requirements: [RTIM-01, RTIM-02]

must_haves:
  truths:
    - "Editor node border turns green when module is running or completed"
    - "Editor node border turns red when module has an error"
    - "Editor node border is gray when module is idle/stopped"
    - "Clicking an error node shows error detail popup with exception message and stack trace"
    - "Status updates are pushed in real-time from runtime to editor (not polling)"
  artifacts:
    - path: "src/OpenAnima.Core/Hubs/IRuntimeClient.cs"
      provides: "Extended with ReceiveModuleStateChanged and ReceiveModuleError methods"
      contains: "ReceiveModuleStateChanged"
    - path: "src/OpenAnima.Core/Wiring/WiringEngine.cs"
      provides: "Pushes module status via IHubContext during execution"
      contains: "IHubContext<RuntimeHub, IRuntimeClient>"
    - path: "src/OpenAnima.Core/Services/EditorStateService.cs"
      provides: "Tracks module runtime states and provides border color logic"
      contains: "ModuleRuntimeState"
    - path: "src/OpenAnima.Core/Components/Shared/NodeCard.razor"
      provides: "Dynamic border color based on module state + error popup on click"
      contains: "GetNodeBorderColor"
  key_links:
    - from: "src/OpenAnima.Core/Wiring/WiringEngine.cs"
      to: "IRuntimeClient"
      via: "IHubContext push in ExecuteModuleAsync"
      pattern: "_hubContext\\.Clients\\.All\\.ReceiveModuleStateChanged"
    - from: "src/OpenAnima.Core/Components/Shared/EditorCanvas.razor"
      to: "EditorStateService"
      via: "SignalR On callback updates module state"
      pattern: "_hubConnection\\.On.*ReceiveModuleStateChanged"
    - from: "src/OpenAnima.Core/Components/Shared/NodeCard.razor"
      to: "EditorStateService"
      via: "GetNodeBorderColor for stroke color"
      pattern: "GetNodeBorderColor"
---

<objective>
Add real-time module status monitoring: extend SignalR to push module execution state (running/error/stopped) from WiringEngine to editor, display as node border colors, and show error details on click.

Purpose: Users see live module health in the visual editor without any polling — green for running, red for error, gray for idle. Error nodes are clickable for diagnostics.
Output: Extended IRuntimeClient, WiringEngine status push, EditorStateService state tracking, NodeCard visual indicators + error popup
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-module-refactoring-runtime-integration/14-CONTEXT.md
@.planning/phases/14-module-refactoring-runtime-integration/14-RESEARCH.md
@.planning/phases/14-module-refactoring-runtime-integration/14-01-SUMMARY.md

<interfaces>
<!-- Key types from Plan 01 that this plan depends on -->

From src/OpenAnima.Contracts/ModuleExecutionState.cs (created in Plan 01):
```csharp
public enum ModuleExecutionState { Idle, Running, Completed, Error }
```

From src/OpenAnima.Contracts/IModuleExecutor.cs (created in Plan 01):
```csharp
public interface IModuleExecutor : IModule
{
    Task ExecuteAsync(CancellationToken ct = default);
    ModuleExecutionState GetState();
    Exception? GetLastError();
}
```

From src/OpenAnima.Core/Hubs/IRuntimeClient.cs (existing):
```csharp
public interface IRuntimeClient
{
    Task ReceiveHeartbeatTick(long tickCount, double latencyMs);
    Task ReceiveHeartbeatStateChanged(bool isRunning);
    Task ReceiveModuleCountChanged(int moduleCount);
}
```

From src/OpenAnima.Core/Wiring/WiringEngine.cs (existing):
```csharp
public class WiringEngine : IWiringEngine
{
    // Constructor: (IEventBus, IPortRegistry, ILogger<WiringEngine>)
    // ExecuteModuleAsync publishes "{moduleId}.execute" event
}
```

From src/OpenAnima.Core/Services/EditorStateService.cs (existing):
```csharp
public class EditorStateService
{
    public event Action? OnStateChanged;
    // Constructor: (IPortRegistry, IConfigurationLoader, IWiringEngine, ILogger)
}
```

From src/OpenAnima.Core/Components/Shared/NodeCard.razor (existing):
```razor
<!-- Status indicator (placeholder for Phase 14) -->
<circle cx="@(_nodeWidth - 12)" cy="@(_titleHeight / 2)" r="4" fill="#555" />
<!-- stroke="@(IsSelected ? "#6c8cff" : "#2a2d3e")" -->
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend IRuntimeClient and WiringEngine for status push</name>
  <files>
    src/OpenAnima.Core/Hubs/IRuntimeClient.cs
    src/OpenAnima.Core/Wiring/WiringEngine.cs
  </files>
  <action>
**IRuntimeClient.cs** — Add two new methods to the existing interface:
- `Task ReceiveModuleStateChanged(string moduleId, string state)` — pushes state changes (Idle/Running/Completed/Error)
- `Task ReceiveModuleError(string moduleId, string errorMessage, string? stackTrace)` — pushes error details for diagnostics

**WiringEngine.cs** — Add IHubContext dependency and push status during execution:
1. Add `IHubContext<RuntimeHub, IRuntimeClient>?` as optional constructor parameter (nullable to avoid breaking existing tests that don't use SignalR).
2. In `ExecuteModuleAsync`, wrap the existing logic:
   - Before execution: push `ReceiveModuleStateChanged(moduleId, "Running")`
   - After successful execution: push `ReceiveModuleStateChanged(moduleId, "Completed")`
   - On exception: push `ReceiveModuleError(moduleId, ex.Message, ex.StackTrace)` then `ReceiveModuleStateChanged(moduleId, "Error")`
3. Guard all hub calls with `if (_hubContext != null)` to keep WiringEngine testable without SignalR.
4. Per research pitfall #3: Do NOT push status on every heartbeat tick — only push on actual state changes.
5. Update DI registration in Program.cs if needed to inject IHubContext into WiringEngine factory.

Per user decision: Event-driven real-time push from runtime to editor (not polling).
Per user decision: Editor is read-only monitoring — no start/stop/restart controls.
  </action>
  <verify>
    <automated>cd /home/user/OpenAnima && dotnet build src/OpenAnima.Core/OpenAnima.Core.csproj --no-restore 2>&1 | tail -5</automated>
  </verify>
  <done>IRuntimeClient has ReceiveModuleStateChanged and ReceiveModuleError methods. WiringEngine pushes status via IHubContext during ExecuteModuleAsync. Existing tests still pass (nullable hub context).</done>
</task>

<task type="auto">
  <name>Task 2: Add module state tracking to EditorStateService and visual indicators to NodeCard</name>
  <files>
    src/OpenAnima.Core/Services/EditorStateService.cs
    src/OpenAnima.Core/Components/Shared/NodeCard.razor
    src/OpenAnima.Core/Components/Shared/EditorCanvas.razor
  </files>
  <action>
**EditorStateService.cs** — Add module runtime state tracking:
1. Add inner record: `public record ModuleRuntimeState(string State, string? ErrorMessage, string? StackTrace, DateTime LastUpdated)`
2. Add `Dictionary<string, ModuleRuntimeState> _moduleStates = new()`
3. Add `UpdateModuleState(string moduleId, string state)` — updates state dict, fires OnStateChanged
4. Add `UpdateModuleError(string moduleId, string errorMessage, string? stackTrace)` — updates with Error state + error details, fires OnStateChanged
5. Add `ModuleRuntimeState? GetModuleState(string moduleId)` — returns state or null
6. Add `string GetNodeBorderColor(string moduleId)` — returns hex color:
   - "Running" → "#00ff00" (green)
   - "Completed" → "#00ff00" (green)
   - "Error" → "#ff0000" (red)
   - default (Idle/unknown) → "#808080" (gray)

Per user decision: green=running, red=error, gray=stopped.

**EditorCanvas.razor** — Subscribe to SignalR callbacks for module status:
1. In OnInitializedAsync (or wherever HubConnection is set up), add:
   - `_hubConnection.On<string, string>("ReceiveModuleStateChanged", (moduleId, state) => { _editorState.UpdateModuleState(moduleId, state); InvokeAsync(StateHasChanged); })`
   - `_hubConnection.On<string, string, string?>("ReceiveModuleError", (moduleId, errorMsg, stackTrace) => { _editorState.UpdateModuleError(moduleId, errorMsg, stackTrace); InvokeAsync(StateHasChanged); })`
2. If EditorCanvas doesn't have a HubConnection yet, create one connecting to RuntimeHub.

Per research pitfall #5: Use `InvokeAsync(StateHasChanged)` for thread safety in SignalR callbacks.

**NodeCard.razor** — Replace placeholder status indicator with dynamic visuals:
1. Replace the hardcoded `fill="#555"` status circle with dynamic color from `_editorState.GetNodeBorderColor(Node.ModuleId)`.
2. Change the card border stroke to also reflect module state: use `_editorState.GetNodeBorderColor(Node.ModuleId)` when not selected (keep blue border when selected).
3. Add error popup: When module state is "Error" and user clicks the status circle, show a `<foreignObject>` overlay with error message and stack trace. Style as a dark tooltip/popup positioned near the node.
4. Add `_showErrorPopup` bool state and toggle on status circle click.
5. Error popup shows: module name, error message, stack trace (scrollable if long), close button.

Per user decision: Click on error node to pop up detailed error information (exception message, stack trace).
  </action>
  <verify>
    <automated>cd /home/user/OpenAnima && dotnet build src/OpenAnima.Core/OpenAnima.Core.csproj --no-restore 2>&1 | tail -5</automated>
  </verify>
  <done>EditorStateService tracks module states with color mapping. EditorCanvas subscribes to SignalR module status callbacks. NodeCard shows dynamic border color (green/red/gray) and error popup on click. Build succeeds.</done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds for OpenAnima.Core
- `dotnet test` — existing tests still pass (WiringEngine backward compatible with nullable hub context)
- NodeCard renders dynamic border colors based on module state
- Error popup appears when clicking error status indicator
</verification>

<success_criteria>
- IRuntimeClient extended with module status methods
- WiringEngine pushes Running/Completed/Error states via SignalR during execution
- EditorStateService tracks module states and provides border color logic
- NodeCard displays green/red/gray borders and error detail popup
- All status updates are push-based (no polling)
</success_criteria>

<output>
After completion, create `.planning/phases/14-module-refactoring-runtime-integration/14-02-SUMMARY.md`
</output>
