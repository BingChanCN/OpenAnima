---
phase: 12-wiring-engine-execution-orchestration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/OpenAnima.Core/Wiring/ConnectionGraph.cs
  - tests/OpenAnima.Tests/Unit/ConnectionGraphTests.cs
autonomous: true
requirements: [WIRE-01, WIRE-02]

must_haves:
  truths:
    - "Topological sort produces correct level-based execution order for any valid DAG"
    - "Cycle detection rejects circular dependencies with clear error message naming the cycle"
    - "Isolated nodes (no connections) appear in level 1"
    - "Fan-out connections produce correct dependency ordering"
  artifacts:
    - path: "src/OpenAnima.Core/Wiring/ConnectionGraph.cs"
      provides: "Graph data structure with Kahn's algorithm for level-parallel topological sort and cycle detection"
      exports: ["ConnectionGraph", "AddNode", "AddConnection", "GetExecutionLevels", "HasCycle"]
    - path: "tests/OpenAnima.Tests/Unit/ConnectionGraphTests.cs"
      provides: "Unit tests for topological sort and cycle detection"
      min_lines: 80
  key_links:
    - from: "src/OpenAnima.Core/Wiring/ConnectionGraph.cs"
      to: "Kahn's algorithm"
      via: "BFS-based level extraction with in-degree tracking"
      pattern: "GetExecutionLevels.*List<List<string>>"
---

<objective>
TDD-driven ConnectionGraph implementing Kahn's algorithm for level-parallel topological sort with integrated cycle detection.

Purpose: Core graph algorithm that determines module execution order and prevents circular dependencies — the foundation WIRE-01 and WIRE-02 depend on.
Output: ConnectionGraph class with full test coverage via RED→GREEN→REFACTOR cycle.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-wiring-engine-execution-orchestration/12-RESEARCH.md

<interfaces>
<!-- Key types from Phase 11 that ConnectionGraph will work alongside (not import directly — ConnectionGraph operates on string module IDs) -->

ConnectionGraph is a pure graph algorithm class. It works with string node IDs (module IDs).
No dependency on Phase 11 port types — the WiringEngine (Plan 03) bridges between port metadata and graph nodes.

Design from research:
- Kahn's algorithm (BFS-based) for level-parallel execution ordering
- In-degree tracking for zero-dependency node identification
- Cycle detection via incomplete processing check (processedNodes != totalNodes)
- Level grouping: nodes at same topological level collected into List<string> for parallel execution
</interfaces>
</context>

<feature>
  <name>ConnectionGraph with Topological Sort and Cycle Detection</name>
  <files>src/OpenAnima.Core/Wiring/ConnectionGraph.cs, tests/OpenAnima.Tests/Unit/ConnectionGraphTests.cs</files>
  <behavior>
    ConnectionGraph manages a directed graph of module IDs and produces level-based execution order.

    Cases:
    - Empty graph → returns empty list of levels
    - Single node, no connections → returns [[nodeA]]
    - Linear chain A→B→C → returns [[A], [B], [C]]
    - Diamond A→B, A→C, B→D, C→D → returns [[A], [B, C], [D]]
    - Fan-out A→B, A→C, A→D → returns [[A], [B, C, D]]
    - Cycle A→B→C→A → throws InvalidOperationException with message containing "Circular dependency"
    - Self-loop A→A → throws InvalidOperationException with "Circular dependency"
    - Multiple disconnected subgraphs → all roots in level 1
    - HasCycle() returns true for cyclic graph, false for acyclic
    - AddNode() registers node without connections (for isolated modules)
    - RemoveNode() removes node and all its connections
    - GetNodeCount() returns total registered nodes
  </behavior>
  <implementation>
    Implement ConnectionGraph class in src/OpenAnima.Core/Wiring/ namespace OpenAnima.Core.Wiring:

    Public API:
    - void AddNode(string nodeId) — register a node (idempotent)
    - void AddConnection(string sourceId, string targetId) — add directed edge (auto-registers nodes)
    - void RemoveNode(string nodeId) — remove node and all edges
    - List<List<string>> GetExecutionLevels() — Kahn's algorithm, throws on cycle
    - bool HasCycle() — returns true if cycle exists (non-throwing)
    - int GetNodeCount() — total nodes

    Internal state:
    - Dictionary<string, HashSet<string>> _adjacencyList (outgoing edges)
    - Dictionary<string, int> _inDegree (incoming edge count)

    Kahn's algorithm implementation:
    1. Copy in-degree map
    2. Enqueue all nodes with in-degree 0
    3. Process level-by-level (snapshot queue size per level)
    4. Decrement neighbors' in-degree, enqueue when reaches 0
    5. After loop: if processedCount != totalNodes → cycle detected

    Error message format for cycle: "Circular dependency detected: {processed}/{total} modules could be ordered. Check for cycles in module connections."
  </implementation>
</feature>

<verification>
dotnet test tests/OpenAnima.Tests/ --filter "FullyQualifiedName~ConnectionGraph" -v normal
dotnet build src/OpenAnima.Core/ --no-restore
</verification>

<success_criteria>
- All ConnectionGraph unit tests pass (RED→GREEN cycle completed)
- GetExecutionLevels returns correct level groupings for linear, diamond, and fan-out graphs
- Cycle detection throws InvalidOperationException with descriptive message
- HasCycle returns correct boolean without throwing
- Solution builds with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-wiring-engine-execution-orchestration/12-01-SUMMARY.md`
</output>
