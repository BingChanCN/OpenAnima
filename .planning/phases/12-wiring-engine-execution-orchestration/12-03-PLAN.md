---
phase: 12-wiring-engine-execution-orchestration
plan: 03
type: execute
wave: 2
depends_on: [12-01, 12-02]
files_modified:
  - src/OpenAnima.Core/Wiring/WiringEngine.cs
  - src/OpenAnima.Core/Wiring/DataCopyHelper.cs
  - tests/OpenAnima.Tests/Integration/WiringEngineIntegrationTests.cs
autonomous: true
requirements: [WIRE-01, WIRE-02, WIRE-03]

must_haves:
  truths:
    - "Runtime executes modules in correct dependency order when wiring configuration is loaded"
    - "User creates circular connection and receives clear error message preventing execution"
    - "Data sent to output port arrives at all connected input ports during execution"
    - "Errored module's downstream nodes are skipped while unaffected branches continue"
    - "Fan-out delivers independent deep copies to each downstream port"
  artifacts:
    - path: "src/OpenAnima.Core/Wiring/WiringEngine.cs"
      provides: "Main orchestration engine: load config, build graph, execute level-parallel, route data"
      exports: ["WiringEngine", "LoadConfiguration", "ExecuteAsync", "UnloadConfiguration"]
    - path: "src/OpenAnima.Core/Wiring/DataCopyHelper.cs"
      provides: "Deep copy utility for fan-out data isolation"
      exports: ["DataCopyHelper", "DeepCopy"]
    - path: "tests/OpenAnima.Tests/Integration/WiringEngineIntegrationTests.cs"
      provides: "Integration tests for end-to-end wiring execution"
      min_lines: 80
  key_links:
    - from: "src/OpenAnima.Core/Wiring/WiringEngine.cs"
      to: "src/OpenAnima.Core/Wiring/ConnectionGraph.cs"
      via: "Build graph from config connections, get execution levels"
      pattern: "ConnectionGraph.*GetExecutionLevels"
    - from: "src/OpenAnima.Core/Wiring/WiringEngine.cs"
      to: "src/OpenAnima.Core/Wiring/ConfigurationLoader.cs"
      via: "Load and validate wiring configuration"
      pattern: "ConfigurationLoader.*LoadAsync"
    - from: "src/OpenAnima.Core/Wiring/WiringEngine.cs"
      to: "src/OpenAnima.Core/Events/EventBus.cs"
      via: "Subscribe to output port events, publish to input port events for data routing"
      pattern: "EventBus.*Subscribe.*PublishAsync"
    - from: "src/OpenAnima.Core/Wiring/DataCopyHelper.cs"
      to: "System.Text.Json.JsonSerializer"
      via: "Serialize/deserialize round-trip for deep copy"
      pattern: "JsonSerializer.*Serialize.*Deserialize"
---

<objective>
WiringEngine that orchestrates level-parallel module execution with EventBus-based data routing and deep copy fan-out.

Purpose: The central orchestrator that ties ConnectionGraph (Plan 01) and ConfigurationLoader (Plan 02) together with the existing EventBus to fulfill all three WIRE requirements — topological execution, cycle rejection, and data routing.
Output: WiringEngine service, DataCopyHelper utility, integration tests.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-wiring-engine-execution-orchestration/12-RESEARCH.md
@.planning/phases/12-wiring-engine-execution-orchestration/12-01-SUMMARY.md
@.planning/phases/12-wiring-engine-execution-orchestration/12-02-SUMMARY.md

<interfaces>
<!-- From Plan 01: ConnectionGraph -->
```csharp
// src/OpenAnima.Core/Wiring/ConnectionGraph.cs
namespace OpenAnima.Core.Wiring;

public class ConnectionGraph
{
    public void AddNode(string nodeId);
    public void AddConnection(string sourceId, string targetId);
    public void RemoveNode(string nodeId);
    public List<List<string>> GetExecutionLevels(); // throws on cycle
    public bool HasCycle();
    public int GetNodeCount();
}
```

<!-- From Plan 02: WiringConfiguration + ConfigurationLoader -->
```csharp
// src/OpenAnima.Core/Wiring/WiringConfiguration.cs
namespace OpenAnima.Core.Wiring;

public record WiringConfiguration(string Name, string Version, List<ModuleNode> Nodes, List<PortConnection> Connections);
public record ModuleNode(string ModuleId, string ModuleName, VisualPosition Position, VisualSize Size);
public record PortConnection(string SourceModuleId, string SourcePortName, string TargetModuleId, string TargetPortName);
public record VisualPosition(double X, double Y);
public record VisualSize(double Width, double Height);
```

```csharp
// src/OpenAnima.Core/Wiring/ConfigurationLoader.cs
namespace OpenAnima.Core.Wiring;

public class ConfigurationLoader
{
    public async Task SaveAsync(WiringConfiguration config, CancellationToken ct = default);
    public async Task<WiringConfiguration> LoadAsync(string configName, CancellationToken ct = default);
    public ValidationResult ValidateConfiguration(WiringConfiguration config);
    public List<string> ListConfigurations();
}
```

<!-- From Phase 11: EventBus -->
```csharp
// src/OpenAnima.Contracts/IEventBus.cs
public interface IEventBus
{
    Task PublishAsync<TPayload>(ModuleEvent<TPayload> evt, CancellationToken ct = default);
    IDisposable Subscribe<TPayload>(string eventName, Func<ModuleEvent<TPayload>, CancellationToken, Task> handler, Func<ModuleEvent<TPayload>, bool>? filter = null);
}
```

```csharp
// src/OpenAnima.Contracts/ModuleEvent.cs
public class ModuleEvent<TPayload> : ModuleEvent
{
    public TPayload Payload { get; set; } = default!;
}
```

<!-- From Phase 11: PortRegistry -->
```csharp
// src/OpenAnima.Core/Ports/PortRegistry.cs
public class PortRegistry
{
    public List<PortMetadata> GetPorts(string moduleName);
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: DataCopyHelper and WiringEngine core</name>
  <files>src/OpenAnima.Core/Wiring/DataCopyHelper.cs, src/OpenAnima.Core/Wiring/WiringEngine.cs</files>
  <action>
    **DataCopyHelper** (`src/OpenAnima.Core/Wiring/DataCopyHelper.cs`):
    Create static class in namespace `OpenAnima.Core.Wiring`:
    - `static T DeepCopy<T>(T obj)` — JsonSerializer round-trip for deep copy
    - Optimization: if obj is null, return default; if obj is string, return as-is (strings are immutable)
    - Use System.Text.Json.JsonSerializer

    **WiringEngine** (`src/OpenAnima.Core/Wiring/WiringEngine.cs`):
    Create class in namespace `OpenAnima.Core.Wiring`.

    Constructor takes:
    - IEventBus eventBus
    - PortRegistry portRegistry
    - ILogger<WiringEngine> logger

    Internal state:
    - ConnectionGraph? _graph
    - WiringConfiguration? _currentConfig
    - List<IDisposable> _subscriptions (for EventBus subscription cleanup)
    - HashSet<string> _failedModules (track errored modules for isolated failure)

    Public methods:

    1. `void LoadConfiguration(WiringConfiguration config)`
       - Dispose existing subscriptions (prevent leaks — pitfall #5 from research)
       - Build ConnectionGraph from config.Connections (AddNode for each ModuleNode, AddConnection for each PortConnection using SourceModuleId→TargetModuleId)
       - Call _graph.GetExecutionLevels() to validate no cycles (throws if cycle — WIRE-02)
       - Set up EventBus subscriptions for data routing:
         For each PortConnection: subscribe to event "{sourceModuleId}.port.{sourcePortName}" and on receive, deep copy payload, publish to "{targetModuleId}.port.{targetPortName}"
       - Store config as _currentConfig

    2. `async Task ExecuteAsync(CancellationToken ct = default)`
       - Throw if no config loaded
       - Get execution levels from _graph.GetExecutionLevels()
       - Clear _failedModules set
       - For each level:
         - Filter out modules whose upstream dependencies are in _failedModules (isolated failure)
         - Execute remaining modules in parallel via Task.WhenAll
         - Each module execution: publish "{moduleId}.execute" event, catch exceptions and add to _failedModules

    3. `void UnloadConfiguration()`
       - Dispose all subscriptions
       - Clear _graph, _currentConfig, _failedModules

    4. `WiringConfiguration? GetCurrentConfiguration()` — returns _currentConfig

    5. `bool IsLoaded` — property, returns _currentConfig != null

    Per user decisions:
    - Level-parallel execution (Task.WhenAll within level, sequential between levels)
    - Isolated failure (catch per-module, skip downstream)
    - Event-driven triggering (ExecuteAsync called on-demand, not on tick)
    - Push-based data routing (subscriptions push data downstream)
    - Fan-out uses deep copy (DataCopyHelper.DeepCopy for each downstream)
    - Trust connection-time validation (no runtime type re-checking)
    - No execution status events (deferred to Phase 13/14)
  </action>
  <verify>
    <automated>dotnet build src/OpenAnima.Core/ --no-restore 2>&1 | tail -5</automated>
  </verify>
  <done>WiringEngine compiles with LoadConfiguration (builds graph, validates cycles, sets up routing), ExecuteAsync (level-parallel with isolated failure), and UnloadConfiguration (disposes subscriptions). DataCopyHelper provides JsonSerializer-based deep copy.</done>
</task>

<task type="auto">
  <name>Task 2: WiringEngine integration tests</name>
  <files>tests/OpenAnima.Tests/Integration/WiringEngineIntegrationTests.cs</files>
  <action>
    Create `tests/OpenAnima.Tests/Integration/WiringEngineIntegrationTests.cs`.

    Test setup:
    - Create real EventBus (with NullLogger), PortRegistry, WiringEngine instances
    - Register test modules with ports in PortRegistry (use PortDiscovery on test-decorated classes or manually register PortMetadata)
    - Define test-only module classes with [InputPort] and [OutputPort] attributes inside the test class

    Tests to write:

    1. `LoadConfiguration_ValidDAG_BuildsExecutionLevels`
       - Create config with A→B→C chain
       - LoadConfiguration succeeds without throwing
       - Verify IsLoaded is true

    2. `LoadConfiguration_CyclicGraph_ThrowsWithMessage`
       - Create config with A→B→C→A cycle
       - Assert LoadConfiguration throws InvalidOperationException
       - Assert message contains "Circular dependency"

    3. `ExecuteAsync_LinearChain_ExecutesInOrder`
       - Create A→B→C config
       - Subscribe to execute events, record order
       - Call ExecuteAsync
       - Verify A executes before B, B before C

    4. `ExecuteAsync_ParallelLevel_ExecutesConcurrently`
       - Create A→B, A→C config (B and C at same level)
       - LoadConfiguration, ExecuteAsync
       - Verify A executes first, then B and C execute (order between B/C doesn't matter)

    5. `DataRouting_FanOut_EachReceiverGetsIndependentCopy`
       - Create config where module A output connects to B input and C input
       - Subscribe to B and C input port events
       - Publish data on A's output port
       - Verify both B and C receive data
       - Verify modifying B's copy doesn't affect C's copy (deep copy verification)

    6. `ExecuteAsync_ModuleError_SkipsDownstream`
       - Create A→B→C config
       - Make B's execute handler throw
       - Verify A executes, B fails, C is skipped
       - No unhandled exception from ExecuteAsync

    7. `UnloadConfiguration_DisposesSubscriptions`
       - LoadConfiguration, then UnloadConfiguration
       - Verify IsLoaded is false
       - Publish events on old port names — no handlers fire

    Use TaskCompletionSource with timeout for async event verification (pattern from Phase 11 tests).
    Use [Trait("Category", "Integration")] on test class.
  </action>
  <verify>
    <automated>dotnet test tests/OpenAnima.Tests/ --filter "FullyQualifiedName~WiringEngine" -v normal</automated>
  </verify>
  <done>All 7 integration tests pass: linear execution order, parallel level execution, fan-out deep copy, cycle rejection, isolated failure, subscription cleanup.</done>
</task>

</tasks>

<verification>
dotnet test tests/OpenAnima.Tests/ --filter "FullyQualifiedName~WiringEngine" -v normal
dotnet build src/OpenAnima.Core/ --no-restore
dotnet test tests/OpenAnima.Tests/ -v normal  # All existing tests still pass
</verification>

<success_criteria>
- WiringEngine.LoadConfiguration builds graph and rejects cycles with clear error (WIRE-02)
- WiringEngine.ExecuteAsync runs modules in topological order with level-parallel execution (WIRE-01)
- EventBus subscriptions route data between connected ports with deep copy for fan-out (WIRE-03)
- Isolated failure: errored module's downstream skipped, unaffected branches continue
- All integration tests pass
- All existing tests (Phase 11) still pass — no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/12-wiring-engine-execution-orchestration/12-03-SUMMARY.md`
</output>
